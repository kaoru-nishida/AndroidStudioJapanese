#AndroidStudio3.1 \u65E5\u672C\u8A9E\u5316\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8
#Tue Nov 21 21:52:20 JST 2017
0.already.contains.a.1={0}にはすでに{1}が含まれています
0.already.contains.field.1={0}にはすでにフィールド{1}が含まれています
0.already.contains.inner.class.named.1={0}には既に{1}という名前の内部クラスが含まれています
0.already.exists.in.the.target.class={0}はすでにターゲットクラスに存在します。
0.already.has.parameter.named.1.use.this.name.anyway={0}にはすでに '' {1} ''という名前のパラメータがあります。
0.contains.call.with.null.argument.for.parameter.1={0}にはパラメータ{1}のヌル引数付きの呼び出しが含まれています
0.has.1.usages.that.are.not.safe.to.delete={0} has {1,choice,1\#1 usage that is|2\#{1,number} usages that are} not safe to delete.
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} has detected {1} code {1,choice,1\#fragment|2\#fragments} in this file that can be replaced with a call to extracted method. Would you like to review and replace {1,choice,1\#it|2\#them}?
0.implements.1={0}は{1}を実装します。
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0}は{1}で、{2}からはアクセスできません。
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0}はメソッド階層の一部です。
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0}はメソッド階層の一部です。
0.is.already.overridden.in.1={0}はすでに{1}でオーバーライドされています。
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0}はインタフェースです。
0.is.an.interface.that.has.no.implementing.classes={0}は実装クラスを持たないインタフェースです
0.is.located.in.a.jar.file={0}は読み取り専用コンテナにあります。
0.is.not.a.legal.fq.name='' {0} ''は合法的なFQ名ではありません
0.is.not.a.legal.java.identifier='' {0} ''は正当なJava識別子ではありません
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0}は{1}からアクセスできません。
0.is.not.an.identifier=<b><code>{0}</code></b> is not a correct identifier to use in <b><code>{1}</code></b>
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}は宣言で初期化されていません。
0.is.not.static.it.cannot.be.moved.to.the.interface={0}は静的ではありません。
0.is.read.only={0}は読み取り専用です。
0.is.used.for.writing.in.1={0}は{1}での書き込みに使用されます
0.refactoring.cannot.be.applied.to.constructors={0}コンストラクタにリファクタリングを適用できません
0.refactoring.is.supported.only.for.final.fields={0}リファクタリングは最終フィールドのみでサポートされています
0.referenced.in.1.will.not.be.accessible.from.module.2={1}で参照されている{0}はモジュール{2}からアクセスできません
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={1}で参照されている{0}はモジュール{2}の生産元からアクセスできません
0.referenced.in.1.will.not.be.accessible.in.module.2={1}で参照されている{0}はモジュール{2}でアクセスできません
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1=インラインメソッドで使用されている{0}は{1}の呼び出しサイトからアクセスできません
0.to.be.renamed.to.1.2={0}の名前を{1} {2}に変更する
0.to.change.signature=署名を変更する{0}
0.upcasts.an.instance.of.1.to.2={0}は{1}のインスタンスを{2}にアップキャストします
0.uses.1.of.an.instance.of.a.2={0}は{2}のインスタンスの{1}を使用します
0.uses.1.which.is.not.accessible.from.the.superclass={0}は{1}を使用します。これはスーパークラスからアクセスできない
0.uses.1.which.is.not.moved.to.the.superclass={0}は{1}を使用しますが、スーパークラスには移動しません
0.uses.1.which.is.pushed.down={0}は{1}を使用しますが、これはプッシュダウンされます
0.uses.1.which.needs.class.instance={0}はクラスインスタンスを必要とする{1}を使用します
0.uses.a.package.local.1={0}はpackage-private {1}を使用します
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0}は非静的{1}を使用しますが、これはパラメータとして渡されません
0.will.be.inaccessible.from.1={0}は{1}からアクセスできません
0.will.become.inaccessible.from.1={0}は{1}からアクセスできなくなります
0.will.hide.renamed.1={0}は名前が変更された{1}を非表示にします
0.will.no.longer.override.1={0}はもはや{1}を無効にしません
0.will.not.be.accessible.from.1.after.inlining=インライン展開後{1}から{0}にアクセスすることはできません
0.will.override.renamed.1={0}は名前が変更された{1}を上書きします
0.with.1.visibility.is.not.accessible.from.2={1}の可視性を持つ{0}は{2}からアクセスできません
ExtractSuperClass.superclass=スーパークラス
New.name.of.method.is.not.java.identifier=メソッドの新しい名前はJavaの識別子ではありません
a.package.local.class.0.will.no.longer.be.accessible.from.1=パッケージローカルクラス{0}は{1}からアクセスできなくなりました
add.object.as.a.parameter.to.constructors.with.name=nameを持つコンストラクタにパラメータとしてオブジェクトを追加する：
add.object.as.a.parameter.with.name=nameを持つパラメータとしてオブジェクトを追加する：
add.parameters.for.fields=フィールドのパラメータを追加する：
add.parameters.for.fields.to.constructors=コンストラクタにフィールドのパラメータを追加する：
all.candidate.variables.have.types.not.in.project=すべての候補変数には、プロジェクトにないタイプがあります
all.candidate.variables.have.unknown.types=すべての候補変数には未知の型があります
all.invocations.and.remove.the.method=すべてをインライン化してメソッドを削除する
all.invocations.in.project=プロジェクト内のすべての呼び出し
all.invocations.keep.the.method=すべてをインライン化してメソッドを保持する
all.references.and.remove.super.class=すべての参照をインライン化してクラスを削除する
all.references.and.remove.the.class=すべての参照をインライン化してクラスを削除する
all.references.and.remove.the.field=すべてをインラインにしてフィールドを削除する
all.references.and.remove.the.local=すべての参照をインライン化し、変数を削除する
all.references.keep.field=すべてをインラインにしてフィールドを維持する
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=これらのディレクトリはすべて移動され、{0}
analyze.and.replace.usages=用途の分析と置換
annotate.field.as.nonnls.checkbox=@NonNlsとしてフィールドに注釈を付ける
anonymous.class.text=匿名クラス
anonymousToInner.class.name.label.text=クラス名：
anonymousToInner.make.class.static.checkbox.text=クラスを静的にする
anonymousToInner.no.inner.class.name=クラス名を指定する必要があります
anonymousToInner.parameters.panel.border.title=コンストラクタパラメータ
anonymousToInner.refactoring.name=匿名を内部に変換する
ask.to.delete.related.file=<html>Related file found\: <code>{0}</code>.<br/>Delete it as well?</html>
ask.to.delete.related.files=<html>Related files found\: <br/><code>{0}</code><br/><br/>Delete them as well?</html>
ask.to.move.related.file=<html>Related file found\: <code>{0}</code>.<br/>Move it as well?</html>
ask.to.move.related.files=<html>Related files found\: <br/><code>{0}</code><br/><br/>Move them as well?</html>
attempting.to.delete.targets.node.text=削除しようとしています
automatic.renamer.enity.name.column={0}名前
automatic.renamer.rename.to.column=名前の変更
boolean.method.result=ブール値のメソッドresult
caller.chooser.callee.method=呼び出し先メソッド
caller.chooser.caller.method=呼び出し元メソッド
caller.chooser.looking.for.callers=発信者を探しています...
cancel.button=キャンセル
cannot.create.directory=ディレクトリを作成できません
cannot.extract.selected.elements.into.include.file=選択した要素をインクルードファイルに抽出できません
cannot.find.or.create.destination.directory=宛先ディレクトリを見つけることができません。
cannot.introduce.field.in.interface=インターフェイスでフィールドを抽出できません
cannot.introduce.variable.in.super.constructor.call=スーパーコンストラクタ呼び出しで変数を抽出できません
cannot.make.abstract.method.static=抽象メソッドを静的にすることはできません
cannot.move=動けない
cannot.move.inner.class.0.into.itself=内部クラス{0}を自分自身に移動できません
cannot.move.package.into.itself=パッケージ自体を移動できません
cannot.perform.refactoring=リファクタリングを実行できません。
cannot.replace.temp.with.query.in.interface=テンポラリをインタフェースのクエリで置き換えることはできません
change.signature.feel.lucky=幸運を感じる
change.signature.leave.blank.default.value=空白のままにする
change.signature.use.selected.value=選択した値を使用する
changeClassSignature.bad.value={0}値が間違っています：パラメータ '' {2} ''の '{1}' '
changeClassSignature.class.label.text={0}の署名を変更する
changeClassSignature.no.type.parameters=クラスは型パラメータを持つことはできません
changeClassSignature.parameters.panel.border.title=パラメーター
changeClassSignature.refactoring.name=クラス署名を変更する
changeSignature.bound.value.column=バインド値：
changeSignature.cannot.resolve.parameter.type=パラメーター '' {1} ''のタイプ '' {0} ''は解決できません。
changeSignature.cannot.resolve.return.type=戻り値の型 '' {0} ''は解決できません。
changeSignature.default.value.column=デフォルト値：
changeSignature.exception.caller.chooser=新しい例外を伝達するメソッドを選択する
changeSignature.exceptions.panel.border.title=例外
changeSignature.exceptions.wont.propagate=例外変更の再帰的伝播は実行されません
changeSignature.name.prompt=名：
changeSignature.no.default.value=新しいパラメータ '' {0} ''が追加されました。
changeSignature.no.return.type=戻り値の型が指定されていません
changeSignature.no.type.for.exception=例外のタイプを指定する
changeSignature.no.type.for.parameter=パラメータ '' {1} ''に{0}タイプを指定してください
changeSignature.not.throwable.type=例外の型が '' {0} ''であるため、java.lang.Throwableを拡張する必要があります。
changeSignature.parameter.caller.chooser=新しいパラメータを伝播するためのメソッドの選択
changeSignature.parameters.wont.propagate=パラメータ変更の再帰的伝播は実行されません
changeSignature.propagate.exceptions.title=例外を伝播する
changeSignature.propagate.parameters.title=パラメータを伝播する...
changeSignature.refactoring.name=署名の変更
changeSignature.return.type.prompt=戻り値の型：
changeSignature.vararg.not.last=Varargパラメータはメソッドのシグネチャの最後にする必要があります
changeSignature.wrong.return.type=間違った戻り値の型： '' {0} ''
changeSignature.wrong.type.for.exception=間違った型： '' {0} ''例外
changeSignature.wrong.type.for.parameter=間違ったタイプ：パラメータ '' {1} ''の '' {0} ''
changing.signature.of.0={0}の署名を変更しています
choose.destination.class=目的地クラスを選択
choose.destination.directory=目的地のディレクトリを選択してください
choose.destination.package=デスティネーションパッケージを選択
choose.the.ones.you.want.to.be.deleted=削除するものを選択してください
class.0.already.exists=クラス{0}は既に存在します
class.0.does.not.exist=クラス{0}は存在しません。
class.0.does.not.have.inheritors=クラス{0}には継承がありません
class.0.is.not.accessible.from.target.1=クラス{0}はターゲット{1}からアクセスできません
class.0.not.found=クラス{0}が見つかりません。
class.constructors.radio=クラスコンストラクタ
class.description=クラス{0}
class.does.not.exist.in.the.project=プロジェクトにクラスが存在しません。
class.does.not.have.base.classes.interfaces.in.current.project={0}は現在のプロジェクトに基本クラス/インタフェースを持っていません
class.does.not.have.base.classes.or.interfaces=クラス{0}には基本クラスまたはインタフェースがありません
class.does.not.have.implicit.default.constructor=クラス{0}に暗黙のデフォルトコンストラクタがありません
class.has.been.successfully.created=クラス{0}は正常に作成されました
class.is.abstract={0}は抽象的なものです。
class.is.interface={0}はインタフェースです。
class.is.never.used=クラスが使用されることはありません
class.name.prompt=クラス名：
classes.to.push.down.members.to=メンバーを{0}にプッシュするクラス
column.name.any.var=任意のvar
column.name.default.value=デフォルト値
column.name.name=名：
column.name.type=タイプ：
comments.elements.header=コメント、文字列、および非コードファイル{0}に出現が見つかりました。
constructor.being.refactored.is.used.in.initializer.of.0=リファクタリングされるコンストラクタは、{0}の初期化子で使用されます。
constructor.cannot.be.made.static=コンストラクタを静的にすることはできません
constructor.description=コンストラクタ{0}
continue.button=持続する
convert.local.to.field.title=ローカルからフィールドへの変換
convert.to.instance.method.title=インスタンスメソッドに変換する
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=すべての参照型パラメータには、プロジェクトにない型があります。
convertToInstanceMethod.all.reference.type.parametres.have.unknown.types=すべての参照型パラメータには未知の型があります
convertToInstanceMethod.method.is.not.static=リファクタリングを実行できません
convertToInstanceMethod.no.parameters.with.reference.type=参照型を持つパラメータはありません
copy,handler.clone.files.directories=ファイル/ディレクトリのクローン作成
copy.class.clone.0.1=クローン{0} {1}
copy.class.copy.0.1={0} {1}をコピー
copy.files.clone.directory.0=ディレクトリ{0}をクローンします。
copy.files.clone.file.0=クローンファイル{0}
copy.files.clone.title=クローン
copy.files.copy.directory.0=ディレクトリ{0}をコピーする
copy.files.copy.file.0=ファイル{0}をコピーしています
copy.files.copy.specified.directories.label=指定したディレクトリをコピーする
copy.files.copy.specified.files.label=指定したファイルをコピーする
copy.files.copy.specified.mixed.label=指定したファイルとディレクトリをコピーする
copy.files.copy.title=コピー
copy.files.new.name.label=新しい名前：
copy.files.to.directory.label=ディレクトリに：
copy.handler.clone.class=クローンクラス
copy.handler.copy.class=コピークラス
copy.handler.copy.files.directories=ファイル/ディレクトリのコピー
create.class.command=クラス{0}を作成する
create.directory=ディレクトリの作成
current.class=現在のクラス
current.method.radio=現在の方法
declaration.s.to.be.generified=生成される宣言{0}
declare.final=最終宣言
declare.folded.parameters=折り畳みパラメータ
declare.generated.annotations=注釈を生成する
declare.static.checkbox=静的宣言
declare.static.pass.fields.checkbox=静的宣言（フィールドをパラメータとして渡す）
declare.varargs.checkbox=varargsを宣言する
default.visibility.border.title=デフォルトの可視性
delegate.members=デリゲートメンバー
delegation.panel.delegate.via.overloading.method=オーバロードメソッドを使用した代理人
delegation.panel.method.calls.label=メソッド呼び出し：
delegation.panel.modify.radio=変更
delete.anyway.button=とにかく削除
delete.include.command={0}を削除
delete.title=削除
delete.variable.declaration=変数宣言を削除する
destination.directory.does.not.correspond.to.any.package=宛先ディレクトリがいずれのパッケージにも対応していません
destination.package=宛先パッケージ：
detecting.possible.conflicts=考えられる競合の検出...
directories.and.all.references.to.package.will.be.renamed=パッケージまたはディレクトリ全体の名前を変更しますか？
directory.0.already.contains.1.named.2=ディレクトリ{0}
directory.0.already.contains.a.file.named.1=ディレクトリ{0}
directory.chooser.hide.non.existent.checkBox.text=存在しないものを隠す
directory.description=ディレクトリ{0}
do.not.replace=交換しないでください
do.not.show.this.message.in.the.future=このメッセージを今後表示しない
do.you.want.to.process.overriding.methods.with.covariant.return.type=オーバーライドするメソッドを処理しますか
do.you.wish.to.continue=続行しますか？
do.you.wish.to.ignore.them.and.continue=あなたはそれらを無視し続けますか？
dont.support.inner.classes=リファクタリング '{0}で内部クラスを'にすることはできません
edit.migration.entry.title=クラス/パッケージの移行の説明の編集
edit.migration.map.title=移行マップの編集
element.will.no.longer.be.accessible={0}は{1}からアクセスできなくなります
encapsulate.fields..encapsulated.fields.visibility.border.title=カプセル化されたフィールドの可視性
encapsulate.fields..package.local.radio=ローカルパッケージ
encapsulate.fields.accessors.visibility.border.title=アクセサの可視性
encapsulate.fields.command.name={0}のフィールドをカプセル化する
encapsulate.fields.encapsulate.border.title=カプセル化する
encapsulate.fields.field.column.name=フィールド
encapsulate.fields.fields.to.be.encapsulated=カプセル化されるフィールド
encapsulate.fields.fields.to.encapsulate.border.title=カプセル化するフィールド
encapsulate.fields.get.access.checkbox=アクセスを取得
encapsulate.fields.getter.column.name=ゲッター
encapsulate.fields.getter.exists=戻り値の型だけでgetter {1}と異なるメソッド{0}が既に存在します
encapsulate.fields.no.fields.selected=フィールドが選択されていない
encapsulate.fields.options.border.title=オプション
encapsulate.fields.private.radio=プライベート
encapsulate.fields.protected.radio=保護された
encapsulate.fields.refactoring.cannot.be.applied.to.interface=カプセル化フィールドリファクタリングはインターフェイスに適用できません
encapsulate.fields.set.access.checkbox=アクセスを設定する
encapsulate.fields.setter.column.name=セッター
encapsulate.fields.setter.exists=setter {1}とは戻り値の型だけで異なるメソッド{0}が既に存在します
encapsulate.fields.title=フィールドをカプセル化する
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=フィールドがアクセス可能な場合でもアクセサーを使用する
enter.new.project.name=新しいプロジェクト名を入力：
entity.name.constructor.parameter=パラメータ
entity.name.form=形
entity.name.inheritor=継承者
entity.name.test=テスト
entity.name.variable=変数
error.cannot.be.renamed=この要素の名前を変更することはできません
error.cannot.resolve={0}を解決できません
error.in.injected.lang.prefix.suffix=選択された{0}は、注入された言語文書の読み取り専用部分にあります
error.incorrect.data=不正確なデータ
error.not.supported.for.jsp={0}リファクタリングはJSPでサポートされていません
error.not.supported.for.package.info={0}リファクタリングはpackage-info.javaではサポートされていません
error.out.of.project.element=選択された{0}はプロジェクト内にありません
error.out.of.project.element.default=選択された要素はプロジェクト内にありません
error.title=エラー
error.wrong.caret.position.anonymous=キャレットはリファクタリングするために匿名クラス内に配置する必要があります
error.wrong.caret.position.class=キャレットはリファクタリングするクラスの内部に配置する必要があります
error.wrong.caret.position.constructor=キャレットは、リファクタリングするコンストラクタ内に配置する必要があります
error.wrong.caret.position.local.name=キャレットは、リファクタリングするローカル変数の名前に配置する必要があります
error.wrong.caret.position.local.or.expression.name=キャレットは、リファクタリングするローカル変数または式の名前に配置する必要があります
error.wrong.caret.position.method=キャレットは、リファクタリングするメソッドの内部に配置する必要があります
error.wrong.caret.position.method.or.class.name=キャレットは、リファクタリングするメソッドまたはクラスの名前に配置する必要があります
error.wrong.caret.position.method.or.local.name=キャレットは、リファクタリングする要素の名前に配置する必要があります
error.wrong.caret.position.method.or.variable.name=キャレットは、リファクタリングするメソッドまたは変数の名前に配置する必要があります
error.wrong.caret.position.symbol.to.refactor=キャレットはリファクタリングするシンボルに配置する必要があります
error.wrong.caret.position.symbol.to.rename=キャレットは名前を変更するシンボルに配置する必要があります
error.wrong.name.input=間違った名前：{0}
expand.method.reference.warning=Methodはメソッドリファレンスで使用されます。
expression.result=表現の結果
extract.chained.constructor.checkbox=チェインされたコンストラクタを抽出する
extract.include.file.title=インクルードファイルの抽出
extract.interface.command.name={1}から{0}インタフェースを抽出しています
extract.interface.from=インタフェースの抽出元：
extract.interface.title=抽出インターフェイス
extract.method.control.flow.analysis.failed=コードに構文エラーがあります。
extract.method.method.panel.border=方法
extract.method.title=抽出メソッド
extract.subclass.command=サブクラスの抽出
extract.superclass.command.name={1}からスーパークラス{0}を抽出しています
extract.superclass.elements.header=ディレクトリにメンバーを持つスーパークラスを抽出する
extract.superclass.from=スーパークラスを以下から抽出します。
extract.superclass.title=抽出スーパークラス
extract.to.directory=ディレクトリに展開する：
extractIncludeFile.name=インクルードファイルを抽出する
extractSuper.extract={0}を抽出する
extractSuper.rename.original.class=元のクラスの名前を変更し、可能であれば{0}を使用してください
extractSuper.rename.original.class.to=元のクラスの名前を次のように変更します。
extractSuperInterface.interface=インタフェース
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=ファクトリメソッド名：
field.0.is.already.defined.in.the.1=フィールド{0}は既に{1}に定義されています
field.0.is.never.used=フィールド{0}は使用されません
field.0.is.not.accessible=フィールド{0}は{1}からアクセスできません
field.0.is.not.static=フィールド{0}は静的ではありません。
field.0.will.hide.field.1.of.the.base.class=フィールド{0}は非表示になります
field.declaration.radio=フィールド宣言
field.description=フィールド{0}
field.exists=名前が{0}のフィールド
field.name=フィールド名：
fields.0.are.not.accessible=フィールド{0}は{1}からアクセスできません
fields.to.be.refactored.should.belong.to.the.same.class=リファクタリングするフィールドは、同じクラスに属している必要があります
file.already.exist=ファイル{0}は既に存在します
file.already.exist.title=インクルードファイルを抽出する
file.description=ファイル{0}
functional.interface.broken=機能的な表現には、機能的なインタフェースが、正確な1つの方法
generate.getter.for.delegated.component=委任されたコンポーネントのゲッターを生成する
generify.title=生成する
getter.and.setter.methods.found.for.the.field.0={0}フィールドのGetterメソッドとSetterメソッドが見つかりました。
getter.method.found.for.the.field.0=フィールド{0}のゲッターメソッドが見つかりました。
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0}は、includeディレクティブで置き換えることができるフラグメントを発見しました
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}は重複を検出しませんでした
ignore.button=無視する
information.title=情報
initialize.in.border.title=で初期化する
initializer.for.variable.cannot.be.a.constant.initializer=変数{0}の初期化子を定数初期化子にすることはできません
inline.class.elements.header=インラインクラス
inline.command=インライン{0}
inline.field.border.title=列をなして
inline.field.command=インラインフィールド{0}
inline.field.elements.header=インラインフィールド
inline.field.field.name.label=フィールド{0} {1}
inline.field.title=インラインフィールド
inline.included.file.title=インラインインクルードファイル
inline.local.variable.definition.prompt=インラインローカル変数 '' {0} ''の定義ですか？
inline.local.variable.prompt=インラインローカル変数 '' {0} ''？
inline.method.border.title=列をなして
inline.method.checking.tail.calls.progress=テールコールの使用状況の確認
inline.method.command=インライン化メソッド{0}
inline.method.elements.header=インラインメソッド
inline.method.method.label=メソッド{0} {1}
inline.method.title=インラインメソッド
inline.parameter.command.name=インラインパラメータ{0}
inline.parameter.confirmation=インラインパラメータ '' {0} ''にイニシャライザ '' {1} ''がありますか？
inline.parameter.error.hierarchy=メソッドが継承階層の一部である場合、インライン・パラメータはサポートされません。
inline.parameter.error.varargs=varargsパラメータのインラインはサポートされていません
inline.parameter.refactoring=インラインパラメータ
inline.parameter.replace.with.local.checkbox=ローカル変数で置き換えます
inline.the.contents.include.prompt='' {0} ''の内容をインライン化しますか？
inline.title=列をなして
inline.to.anonymous.border.title=列をなして
inline.to.anonymous.command.name=インラインクラス{0}
inline.to.anonymous.name.label=クラス{0}
inline.to.anonymous.no.abstract=抽象クラスはインライン化できません
inline.to.anonymous.no.inheritors=サブクラスを持つクラスはインライン化できません
inline.to.anonymous.no.multiple.interfaces=複数のインタフェースを実装するクラスはインライン化できません
inline.to.anonymous.no.superclass.and.interface=スーパークラスを持ち、インタフェースを実装しているクラスはインライン化できません
inline.to.anonymous.refactoring=インラインから匿名のクラス
inline.variable.title=インライン変数
inline.vars.elements.header=インライン変数
inlined.method.implements.method.from.0=インラインメソッドは{0}からのメソッドを実装します
inlined.method.overrides.method.from.0=インラインメソッドは{0}からメソッドをオーバーライドします
inner.class.0.is.already.defined.in.class.1=内部クラス{0}は既にクラス{1}に定義されています。
inner.class.0.is.not.static=内部クラス{0}は静的ではありません。
inner.class.exists='' {0} ''という名前の内部クラスが既に定義されています
inner.class.name=内部クラス名：
inner.classes.cannot.have.static.members=内部クラスは静的メンバーを持つことはできません
instance.initializer.description=クラス{0}のインスタンス初期化子
instances.casted.to.java.lang.object=java.lang.Objectにキャストされたインスタンス
instances.of.0.upcasted.to.1.were.found={0}のインスタンスが{1}にアップキャストされました。
instances.upcasted.to.java.lang.object.found=java.lang.Objectにアップキャストされたインスタンスが見つかりました
instances.upcasted.to.object=オブジェクトにアップキャストされたインスタンス
interface.0.does.not.have.inheritors=インターフェイス{0}に継承子がありません
interface.does.not.have.base.interfaces=インタフェース{0}には基本インタフェースがありません
interface.has.been.successfully.created=インタフェース{0}が正常に作成されました
interface.member.dependency.required.by.interfaces=required by {0,choice,1\#interface|2\#interfaces}
interface.name.prompt=インターフェイス名：
introduce.constant.enum.cb=enum定数として抽出する
introduce.constant.field.of.type=型の定数（static finalフィールド）：
introduce.constant.introduce.to.class=クラスへの抽出（完全修飾名）：
introduce.constant.title=抽出定数
introduce.field.field.of.type=タイプのフィールド：
introduce.field.static.field.of.type=タイプの静的フィールド：
introduce.field.title=抽出フィールド
introduce.functional.parameter.title=機能パラメータの抽出
introduce.parameter.command=パラメータを{0}に抽出しています
introduce.parameter.convert.lambda=関数式に変換する
introduce.parameter.elements.header=メソッドにパラメータを追加する
introduce.parameter.title=パラメータの抽出
introduce.parameter.to.method=メソッドにパラメータを抽出する：
introduce.selection.error=選択した要素を使用してリファクタリングを実行できません
introduce.variable.title=変数の抽出
introduced.variable.will.conflict.with.0=導入された変数は{0}と競合します
introducing.variable.may.break.code.logic=変数を導入するとコードロジックが壊れることがある
invalid.expression.context=表現コンテキストが無効です。
invalid.target.package.name.default.package=クラスをデフォルトパッケージに移動できません
invalid.target.package.name.specified=無効なターゲットパッケージ名が指定されています
invert.0.1={0} {1}とその使用法を逆転させる
invert.boolean.elements.header=反転する{0}
invert.boolean.foreach=Foreachパラメータの初期化子を反転することはできません
invert.boolean.name.of.inverted.element=反転{0}の名前：
invert.boolean.refs.to.invert=反転される参照{0}
invert.boolean.title=Invert Boolean
invert.boolean.wrong.type=リファクタリングする変数のメソッドまたはタイプの戻り値の型はboolean
invocations.to.be.inlined=インライン化される呼び出し{0}
is.modified.in.loop.body=ループ本体で{0}が変更されました
is.not.supported.in.the.current.context={0}は現在のコンテキストではサポートされていません
items.to.be.deleted=削除する項目
javadoc.as.is=そのまま
javadoc.copy=コピー
javadoc.for.abstracts=要約のためのJavaDoc
javadoc.move=移動
keep.abstract.column.header=抽象的にする
local.variable.description=ローカル変数{0}
local.will.be.hidden.renamed=名前を変更したフィールドは{0}を非表示にします
locate.caret.inside.a.method=メンバー内にキャレットを配置する
make.0.static={0}を静的にする
make.abstract=抽象化する
make.method.static.title=メソッドを静的にする
make.static.command={0}静的にする
make.static.description.label={0} {1}を静的にする
make.static.elements.header={0}を静的にする
member.column=メンバー
member.info.extends.0={0}を拡張する
member.info.implements.0={0}を実装しています
member.is.already.static=メンバーは既に静的です
members.to.be.moved.should.belong.to.the.same.class=移動するメンバーは同じクラスに属している必要があります
members.to.be.pulled.up=プルアップされるメンバー
members.to.be.pushed.down.panel.title=プッシュダウンされるメンバー
members.to.form.interface=インタフェースを形成するメンバ
members.to.form.superclass=スーパークラスを形成するメンバ
method.0.is.already.defined.in.the.1=メソッド{0}は既に{1}に定義されています
method.0.is.not.static=メソッド{0}は静的ではありません。
method.0.is.overridden.by.1=メソッド{0}は{1}でオーバーライドされています
method.0.will.hide.method.of.the.base.class=メソッド{0}は非表示になります
method.0.will.implement.method.of.the.base.class=メソッド{0}が実装されます
method.0.will.override.a.method.of.the.base.class=メソッド{0}は上書きされます
method.column=方法
method.description=メソッド{0}
method.does.not.have.a.body=メソッド{0}には本文がありません
method.duplicates.found.message={0, choice, 1\#1 code fragment|2\#{0,number} code fragments} found
method.duplicates.method.label=メソッド{0}
method.has.an.empty.body=メソッド{0}には空のボディがあります。
method.is.not.a.constructor=メソッドがコンストラクタではありません
migration.add.button=追加...
migration.class=クラス
migration.dialog.ok.button.text=走る
migration.dialog.title=パッケージとクラスの移行
migration.edit.button=編集...
migration.entry.class=クラス
migration.entry.new.name=新しい名前：
migration.entry.old.name=旧名：
migration.entry.package=パッケージ
migration.map.description.label=地図の説明：
migration.map.name.prompt=マップ名：
migration.map.set.migration.maps=移行マップ
migration.move.down.button=下に移動
migration.move.up.button=上に移動
migration.new.button=新しい...
migration.new.name.column.header=新しい名前
migration.no.usages.found.in.the.project=プロジェクトで使用されている用途はありません
migration.old.name.column.header=旧名
migration.package=パッケージ
migration.package.with.subpackages=サブパッケージを含むパッケージ
migration.remove.button=削除する
migration.title=移行
migration.type.column.header=タイプ
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移動クラスのリファクタリングは匿名クラスには適用できません
move.class.to.inner.command.name={0}を{1}に移動
move.class.to.inner.move.to.self.error=クラスを自分自身に移動することはできません
move.class.to.inner.nonstatic.error=クラスを非静的な内部クラスに移動することはできません
move.classes.command={0}をパッケージ{1}に移動しています
move.classes.destination.make.inner=内部クラスを作る
move.classes.destination.to.package=パッケージ化する
move.classes.elements.header={0}に移動するクラス
move.classes.move.to.another.source.folder=別のソースフォルダに移動する
move.current.directory=現在の移動
move.directories=すべてを動かす
move.directories.elements.header={0}に移動するディレクトリ
move.directories.to.another.source.root={0}ディレクトリを別のソースルートに移動する
move.directory.0=ディレクトリ{0}を移動する
move.directory.to.another.source.root=ディレクトリ{0}を別のソースルートに移動する
move.enum.constant.cb=可能であれば列挙定数として移動する
move.file.0=ファイル{0}を移動する
move.files.elements.header={0}に移動するファイル
move.files.to.directory.label=ディレクトリに：
move.inner.class.command=移動する内部クラス{0}
move.inner.class.to.another.class=内部クラス{0}を別のクラスに移動する
move.inner.class.to.be.moved=移動するクラス
move.inner.class.to.upper.level=内部クラス{0}を上位レベルに移動する
move.inner.to.upper.level.title=内側から上方に移動
move.instance.method.command=移動インスタンスメソッド
move.instance.method.elements.header=インスタンスメソッドの移動
move.instance.method.title=インスタンスメソッドの移動
move.members.elements.header=移動するメンバー
move.members.members.to.be.moved.border.title=移動されるメンバー（静的のみ）
move.members.move.members.from.label=メンバーの移動元：
move.members.title=メンバーを移動
move.members.to.fully.qualified.name.label=To（完全修飾名）：
move.method.enter.a.valid.name.for.parameter=パラメータの有効な名前を入力してください
move.method.is.not.supported.for.0={0}の移動インスタンスメソッドはサポートされていません
move.method.is.not.supported.for.constructors=コンストラクタでMoveメソッドはサポートされていません
move.method.is.not.supported.for.generic.classes=移動メソッドは汎用クラスではサポートされていません
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=メソッドが継承階層の一部である場合、移動メソッドはサポートされません
move.method.this.parameter.label='' {0} .this ''パラメータの名前を選択してください
move.nonstatic.class.from.jsp.not.supported=JSPページからの非静的クラスの移動はサポートされていません
move.package.refactoring.cannot.be.applied.to.default.package=移動パッケージリファクタリングはデフォルトパッケージに適用できません
move.package.to.another.package=パッケージ '' {0} ''を別のパッケージに移動する
move.packages.elements.header={0}に移動するパッケージ
move.packages.to.another.package={0}個のパッケージを別のパッケージに移動する
move.single.class.or.package.name.label={0} {1}に移動
move.single.element.elements.header={0}を{1}に移動する
move.specified.classes=指定されたクラスを移動する
move.specified.classes.to=指定したクラスを次の場所に移動する：
move.specified.directories=指定したディレクトリを移動する
move.specified.elements=指定された要素を移動する
move.specified.files=指定したファイルを移動する
move.specified.packages=指定したパッケージを移動する
move.title=移動
move.to.different.language=ターゲットクラス{2}は{0} {1}とは異なる言語を持っています
move.to.inner.duplicate.inner.class=クラス{0}にはすでに{1}という名前の内部クラスが含まれています
moveInstanceMethod.select.an.instance.parameter=インスタンスパラメータを選択します。
moving.directories.command=ディレクトリの移動
moving.local.classes.is.not.supported=移動するローカルクラスはサポートされていません
multiple.directories.correspond.to.package=パッケージに対応する複数のディレクトリ
name.for.extracted.include.file=抽出されたインクルードファイルの名前（デフォルトの拡張子：{0}）
name.prompt=名
no.button=いいえ
no.class.name.specified=クラス名が指定されていません
no.destination.class.specified=宛先クラスが指定されていません
no.field.name.specified=フィールド名が指定されていません
no.initializer.present.for.the.field=フィールドのイニシャライザがありません
no.interface.name.specified=インタフェース名が指定されていません
no.members.selected=選択されたメンバーは
no.new.name.specified=新しい名前が指定されていません
no.parameter.name.specified=パラメータ名が指定されていません
no.selection=選択なし。
no.superclass.name.specified=スーパークラス名が指定されていません
no.target.directory.specified=ターゲットディレクトリが指定されていません
no.usages.can.be.replaced={0}の使用法はありません
occurences.string=({0,choice,1\#1 occurrence|2\#{0,number} occurrences})
occurences.to.be.migrated=移行対象の出現{0}
occurrences.found.in.comments.strings.and.non.java.files=コメント、文字列、および非コードファイルでの出現数
occurrences.found.in.comments.strings.non.java.files.and.generated.code=コメント、文字列、非コードファイル、および生成されたコードに出現する
occurrences.string=({0,choice,1\#1 occurrence|2\#{0,number} occurrences})
ok.button=[OK]
only.fields.variables.of.methods.of.valid.type.can.be.considered=フィールド、変数、メソッドパラメータ、または有効な型のメソッドのみを考慮することができます。
package.description=パッケージ{0}
package.does.not.exist=パッケージ{0}は存在しません。
package.for.new.interface=新しいインターフェースのパッケージ：
package.for.new.superclass=新しいスーパークラスのパッケージ：
package.for.original.class=元のクラスのパッケージ：
package.for.original.interface=元のインターフェイス用のパッケージ：
package.occurs.in.package.prefixes.of.the.following.source.folders.n=パッケージ{0}は、次のソースフォルダのパッケージプレフィックスで発生します。
parameter.description=パラメータ{0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=パラメータ初期化子には{0}が含まれていますが、メソッドのすべての呼び出しがクラスに含まれているわけではありません
parameter.name.prompt=パラメータ名：
parameter.of.type=タイプのパラメータ：
parameters.border.title=パラメーター
pass.outer.class.instance.as.parameter=外部クラスのインスタンスをパラメータとして渡す
path.completion.shortcut=パスの補完に{0}を使用する
please.enter.a.valid.name.for.inverted.element=反転{0}の有効な名前を入力してください
please.enter.a.valid.target.package.name=有効なターゲットパッケージ名を入力してください
press.escape.to.remove.the.highlighting=強調表示を削除するにはEscキーを押します
press.the.do.migrate.button=検索結果パネルの下部にある[移行する]ボタンをクリックします
preview.button=プレビュー
preview.usages.to.be.changed=プレビューを変更する
problems.detected.title=検出された問題
process.duplicates.title={1}の重複{0}を処理しています
process.methods.duplicates.title=処理方法{2}重複（{1}の{0}）
progress.text=用途を探す
pull.members.up.title=メンバーを引き上げる
pull.up.members.to={0}のメンバーを引き上げて：
pullUp.command=メンバーを{0}から引き上げる
push.down.javadoc.panel.title=要約のためのJavaDoc
push.down.members.elements.header=メンバーを{0}からプッシュダウンする
push.down.will.delete.members=メンバーを押し下げると、メンバーが削除されます。
push.members.down.title=メンバーを押し下げる
push.members.from.0.down.label=メンバーを{0}から押し下げる
pushed.members.will.not.be.visible.from.certain.call.sites=プッシュされたメンバーは特定のコールサイトから表示されません
readonly.occurences.found=読み取り専用ファイルで検出された回数
refactor.button=リファクタリング
refactoring.cannot.be.applied.no.sources.attached={0}リファクタリングを適用できません：ソースがアタッチされていません
refactoring.cannot.be.applied.to.abstract.methods={0}抽象メソッドにはリファクタリングを適用できません
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0}インライン非連結コンストラクタにはリファクタリングを適用できません
refactoring.cannot.be.applied.to.vararg.constructors={0}リファクタリングは可変コンストラクタには適用できません
refactoring.cannot.be.performed=リファクタリングは実行できません
refactoring.extract.method.dialog.empty=空の
refactoring.extract.method.dialog.method.name=メソッド名：
refactoring.extract.method.dialog.output.variables=出力変数
refactoring.extract.method.dialog.parameters=パラメーター
refactoring.extract.method.dialog.signature.preview=署名プレビュー
refactoring.extract.method.dialog.title=抽出メソッド
refactoring.introduce.context.error=このコンテキストではリファクタリングを実行できません
refactoring.introduce.name.error=不適切な名前
refactoring.introduce.name.used.error=この名前はすでに使用されています
refactoring.introduce.parameter.object.command.name={1}（）にパラメータクラス{0}が導入されました
refactoring.introduce.parameter.object.method.to.extract.parameters.from.label=パラメータを抽出する方法
refactoring.introduce.parameter.object.method.whose.parameters.are.to.wrapped=パラメータがラップされるメソッド
refactoring.introduce.parameter.object.references.to.be.modified=変更される参照
refactoring.introduce.parameter.object.title=パラメータオブジェクトを導入する
refactoring.introduce.placing.error={0}変数を抽出できません
refactoring.introduce.selection.error=選択した要素を使用してリファクタリングを実行できません
refactoring.introduce.variable.scope.error=既存の変数との名前の衝突
refactoring.introduceVariable=変数リファクタリングを抽出する
refactoring.is.not.supported.for.jsp.classes=リファクタリングはJSPクラスではサポートされていません
refactoring.is.not.supported.for.language={0}は{1}でサポートされていません
refactoring.is.not.supported.for.local.and.jsp.classes=リファクタリングはローカルクラスとJSPクラスではサポートされていません
refactoring.is.not.supported.for.recursive.methods=再帰メソッドを削除するには、{0}リファクタリングを適用しないことがあります。
refactoring.is.not.supported.in.the.current.context={0}現在のコンテキストではリファクタリングがサポートされていません
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=return文が実行フローを中断すると、{0}リファクタリングはサポートされません
references.found.in.code=コード内の参照
references.found.in.generated.code=生成されたコード内の参照
references.in.code=コード{0}の参照
references.in.code.to.0=コードの{0}への参照
references.in.code.to.0.1=コード内の{0} {1}への参照
references.in.code.to.elements.from.migration.map=移行マップ "{0}" {1}の要素へのコード内の参照
references.to.0.to.be.replaced.with.references.to.1="{0}"への参照を "'{1}'への参照に置き換える
references.to.be.changed=変更される参照{0}
related.file=関連ファイル
remove.duplicates.command=重複を削除する
remove.include.prompt=インクルードされたファイルは使用されなくなりました。
remove.parameter.0.no.longer.used=パラメータ '' {0} 'を使用しなくなりました
rename.0.and.its.usages.to={0}とその使用法の名前を次のように変更します。
rename.bound.forms=結合フォームの名前を変更する
rename.bound.forms.title=バインドされたフォームの名前を変更する
rename.constructor.parameters.title=コンストラクタパラメータの名前を変更する
rename.constructor.parameters.with.the.following.names.to=次の名前のパラメータの名前を変更します。
rename.current.directory=現在の名前を変更する
rename.directories=すべての名前を変更する
rename.directories.command.name=ディレクトリの名前を変更する
rename.directory.button.text=ディレクトリの名前を変更する
rename.directory.command.name=ディレクトリの名前を変更する
rename.directory.title=ディレクトリの名前を変更する
rename.forms.with.the.following.names.to=次の名前のフォームの名前を変更します。
rename.implementation.class.to=実装クラスの名前を次のように変更します。
rename.inheritors=継承者の名前を変更する
rename.inheritors.title=継承者の名前を変更する
rename.inheritors.with.the.following.names.to=次の名前の継承者の名前を変更します。
rename.module.title=モジュール名の変更
rename.not.supported=操作はサポートされていません
rename.original.interface.to=元のインターフェイスの名前を次のように変更します。
rename.overloads=過負荷の名前を変更する
rename.package.button.text=パッケージの名前を変更する
rename.parameters.hierarchy=階層内のパラメータの名前を変更する
rename.project=プロジェクトの名前を変更する
rename.project.action.title=プロジェクトの名前を変更...
rename.project.handler.title=プロジェクトの名前を変更する
rename.related.file.dialog.description=関連ファイルの名前を次のように変更します。
rename.tests=テストの名前を変更する
rename.tests.title=テストの名前を変更する
rename.tests.with.the.following.names.to=次の名前でテストの名前を変更します。
rename.title=名前を変更する
rename.variables=変数の名前を変更する
rename.variables.title=変数の名前を変更する
rename.variables.with.the.following.names.to=次の名前の変数の名前を変更します。
renamed.class.will.hide.0.in.1=名前が変更されたクラスは{1}で{0}を非表示にします
renames.project=プロジェクトの名前を変更する
renaming.0.1.to.2={0} {1}から{2}に名前を変更しています
renaming.command.name={0}の名前を変更しています
renaming.something=名前を変更する
replace.all.fields=すべてのフィールドを置換する
replace.all.occurences=すべての出現箇所を置換する（{0}回目）
replace.all.occurences.checkbox=すべての出現箇所を置換
replace.all.occurrences.of.expression.0.occurrences=すべての出現箇所を置換する（{0}）
replace.button=置換
replace.constructor.0.with.a.factory.method=コンストラクタ{0}をファクトリメソッドに置き換える
replace.constructor.with.factory.method=コンストラクタをファクトリメソッドに置き換える
replace.constructor.with.factory.method.title=ファクトリメソッドでコンストラクタを置き換える
replace.constructor.with.factory.target.fq.name=In（完全修飾名）：
replace.default.constructor.of.0.with.a.factory.method={0}のデフォルトコンストラクタをファクトリメソッドに置き換えます
replace.default.constructor.with.factory.method=ファクトリメソッドでデフォルトのコンストラクタを置き換える
replace.fields.inaccessible.in.usage.context=使用コンテキストでアクセスできないフィールドを置き換える
replace.fields.used.in.expressions.with.their.getters=式で使用されるフィールドをゲッターに置き換える
replace.fragment=フラグメントを置換
replace.inheritance.from=委任継承で置き換える：
replace.inheritance.with.delegation.command={0}の継承を代理に置き換える
replace.inheritance.with.delegation.elements.header=継承を委譲で置き換える
replace.inheritance.with.delegation.title=継承を委任で置き換える
replace.instance.qualifiers.with.class.references=インスタンス修飾子をクラス参照に置き換える
replace.method.code.duplicates.title=コードの重複を置き換える
replace.method.duplicates.scope.chooser.message=分析範囲
replace.method.duplicates.scope.chooser.title={0}スコープを指定する
replace.temp.with.query.title=テンポをクエリに置き換える
replace.this.code.fragment=このコードフラグメントを置き換えますか？
replace.this.code.fragment.and.change.signature=メソッドシグネチャは次のように変更されます。
replace.this.code.fragment.and.make.method.static=（メソッドは静的になります）
replace.this.code.fragment.and.make.method.static.visible=（メソッドは静的になり、{0}になります）
replace.this.code.fragment.and.make.method.visible=（方法は{0}になります）
replace.with.method.call.does.not.work.for.constructors=コンストラクタでメソッド呼び出しを置換できない
replace.write.access.occurrences=書き込みアクセスの置換
replacing.inheritance.with.delegation=継承を委譲に置き換える
rerun.safe.delete=再実行セーフ削除
retry.command=リトライ
safe.delete.command={0}を削除しています
safe.delete.comment.occurences.header=コメント、文字列、非コードファイル{0}に出現しました。
safe.delete.conflict.title=コード内の参照を削除する可能性があります。
safe.delete.of.those.0.in.comments.strings.non.code=Of those {0,choice,1\#1 usage is|2\#{0,number} usages are} in strings, comments, non-code files or generated code.
safe.delete.title=安全な削除
search.for.references=リファレンスを検索する
search.for.text.occurrences=テキストの出現を検索する
search.in.comments.and.strings=コメントと文字列で検索する
searching.for.duplicates=重複を検索中...
searching.for.variables=変数の検索
select.all.button=すべて選択
select.migration.map=移行マップを選択：
select.refactoring.title=リファクタリングの選択
select.source.root.chooser.title=ソースルートを選択
select.target.directory=ターゲットディレクトリを選択
select.target.directory.description=このディレクトリにファイルが作成されます
selected.block.contains.invocation.of.another.class.constructor=選択されたブロックには別のクラスコンストラクタの呼び出しが含まれます
selected.block.should.represent.a.set.of.statements.or.an.expression=選択されたブロックは、一連のステートメントまたは式を表す必要があります
selected.block.should.represent.an.expression=選択されたブロックは式を表すはずです
selected.expression.cannot.be.a.constant.initializer=選択された式は定数初期化子にはなりません
selected.expression.has.void.type=選択された式にvoid型があります。
selection.does.not.form.a.fragment.for.extraction=選択は抽出のための断片を形成しない
setter.method.found.for.the.field.0={0}フィールドのセッターメソッドが見つかりました。
setup.method.radio=setUpメソッド
signature.preview.border.title=署名プレビュー
source.and.destination.classes.should.be.different=ソースクラスと宛先クラスは異なるはずです
source.folder.0.has.package.prefix.1=ソースフォルダ{0}にはパッケージ接頭辞 '' {1} ''があります
static.initializer.description=クラス{0}の静的初期化子
statusBar.noUsages=発生していない
statusBar.refactoring.result={0, choice, 1\#1 occurrence|2\#{0,number} occurrences} changed
superclass.cannot.be.extracted.from.an.enum=スーパークラスはenumから抽出できません
superclass.cannot.be.extracted.from.an.interface=スーパークラスはインタフェースから抽出できません
superclass.name=スーパークラス名：
synthetic.jsp.class.is.referenced.in.the.method=合成jspクラスはメソッドで参照されています
target.0.is.not.accessible.from.1=ターゲット{0}は{1}からアクセスできません
target.destination.folder=ターゲットの宛先ディレクトリ：
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=キャレットは、リファクタリングするクラス、メソッド、またはフィールドに配置する必要があります
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=キャレットはクラス内に配置して、メンバーを
the.caret.should.be.positioned.inside.a.class.to.push.members.from=キャレットはクラス内に配置して、メンバーを
the.caret.should.be.positioned.on.the.included.file.to.inline=キャレットは、インクルードされたファイル参照に配置する必要があります
the.field.should.be.declared.in.a.class=フィールドはクラス内で宣言する必要があります
the.file.will.be.copied.to.this.directory=ファイルはこのディレクトリにコピーされます
the.file.will.be.moved.to.this.directory=ファイルはこのディレクトリに移動されます
the.following.problems.were.found=次の問題が見つかりました：
the.language.for.selected.elements.has.no.associated.file.type=選択された要素の言語には、関連するファイルタイプがありません
there.are.going.to.be.multiple.destination.files.with.the.same.name=同じ名前の複数の宛先ファイルが存在する可能性があります
there.are.multiple.exit.points.in.the.selected.code.fragment=選択したコードフラグメントには複数の終了点があります
there.are.multiple.output.values.for.the.selected.code.fragment=選択したコードフラグメントには複数の出力値があります。
there.are.no.variables.that.have.reference.type=参照型を持つ変数はありません
there.are.unused.methods.that.override.methods.you.delete=削除するメソッドをオーバーライドする未使用のメソッドがあります。
there.is.already.a.0.in.1={1}にはすでに{0}があります
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter={1}には既に{0}があります。
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter={1}には既に{0}があります。
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=すでに{0}があります。
there.is.already.a.0.it.will.conflict.with.the.renamed.1=すでに{0}があります。
these.package.prefixes.will.be.changed=これらのパッケージ接頭辞は変更されます。
this.invocation.only.and.keep.the.method=これをインライン化してメソッドを保持する
this.member.does.not.seem.to.belong.to.any.class=このメンバーはどのクラスにも属していないようです
this.method=この方法
this.reference.only.and.keep.super.class=この参照のみをインライン化し、スーパークラスを維持する
this.reference.only.and.keep.the.class=この参照のみをインライン化し、クラスを維持する
this.reference.only.and.keep.the.field=これをインライン化してフィールドを維持する
this.reference.only.and.keep.the.variable=この参照のみをインライン化し、変数を保持する
to.delete.with.usage.search=削除する（使用法検索で）
to.refactor=リファクタリングする
to.rename=名前を変更する
turn.refs.to.super.command={0}の使用法を{1}に置き換える
turnRefsToSuper.change.usages.to={0}の使用法を次のように変更します：
turnRefsToSuper.use.superclass.in.instanceof=instanceofにinterface / superclassを使用する
type.cook.command=生成する
type.cook.drop.obsolete.casts=廃止されたキャストを削除
type.cook.elements.header=発生する範囲
type.cook.generify.objects=オブジェクトの生成
type.cook.leave.object.parameterized.types.raw=オブジェクトでパラメータ化された型を生かしたままにする
type.cook.perform.exhaustive.search=網羅的な検索を実行する
type.cook.preserve.raw.arrays=生の配列を保持する
type.cook.produce.wildcard.types=ワイルドカードタイプを作成する
type.cook.ratio.generified={0,choice,-1\#not calculated|0\#{0,number} of {1}}
type.cook.report=生成されたアイテム：{0}、キャストが削除されました：{1}
type.migration.exclude.action.text=除外
type.migration.include.action.text=含める
type.migration.migrate.button.text=移行する
type.migration.rerun.button.text=再実行タイプの移行
type.of.the.selected.expression.cannot.be.determined=選択された式のタイプは判別できません。
unable.to.start.type.migration=タイプの移行を開始できません
unknown.expression.type=未知の表現タイプ。
unselect.all.button=すべての選択を解除する
unsupported.refs.found={0}ファイルでサポートされていない参照が見つかりました
unused.overriding.methods.title=未使用のオーバーライドメソッド
usageView.doAction=リファクタリングを行う
usageView.need.reRun=リファクタリング操作を実行できません。
usageView.tabText=リファクタリングプレビュー
usageView.usagesText=用途
usages.detected=検出された用途
usages.detected.title=検出された用途
use.interface.superclass.in.instanceof=instanceofにinterface / superclassを使用する
use.interface.where.possible.title=可能であればインタフェースを使用する
use.super.references.prompt=この段階で{0}は{1}の使用法を分析できます
use.variable.initializer.to.initialize.parameter=変数初期化子を使用してパラメータを初期化する
used.by.0={0}によって使用されました
uses.0={0}を使用します。
variable.does.not.have.an.initializer=変数{0}に初期化子がありません。
variable.has.no.dominating.definition=インラインで単一の定義を見つけることができません
variable.has.no.initializer=変数{0}に初期化子がありません
variable.is.accessed.for.writing=変数 '' {0} 'は書き込みのためにアクセスされます
variable.is.accessed.for.writing.and.used.with.inlined=別の変数 '' {0} 'の定義は、インライン化されたものと一緒に使用されます
variable.is.never.used=変数{0}は決して使用されません
variable.is.never.used.before.modification=変数{0}は変更前に使用されません
variable.is.referenced.in.multiple.files=変数{0}は複数のファイルで参照されています
variable.of.type=タイプの変数：
view.usages=用途を表示
visibility.as.is=そのまま
visibility.border.title=可視性
visibility.combo.title=可視性：
visibility.escalate=エスカレート
visibility.package.local=ローカルパッケージ
visibility.private=プライベート
visibility.protected=保護された
visibility.public=パブリック
warning.title=警告
what.would.you.like.to.do=あなたは何をしたいですか？
would.you.like.to.replace.default.constructor.of.0.with.factory.method={0}のデフォルトのコンストラクタをファクトリメソッドに置き換えますか？
yes.button=はい
