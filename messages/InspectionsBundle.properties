#AndroidStudio3.1 \u65E5\u672C\u8A9E\u5316\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8
#Tue Nov 21 21:52:20 JST 2017
-d=<directorypath>  --  directory to be inspected. Optional. Whole project is inspected by default.
-e=--  skip  
-profileName=--  name of a profile defined in project 
-profilePath=--  absolute path to the profile file
-v[0|1|2]=--  verbose level. 0 - silent, 1 - verbose, 2 - most verbose. 
Available=options are\:
[<options>]=
access.can.be.tightened=アクセスを強化することができます
access.static.via.instance=インスタンス参照を介して静的メンバーにアクセスする
annotate.overridden.methods.as.notnull=オーバーライドされたメソッドに「@ {0}」と注釈を付ける
annotate.overridden.methods.parameters=オーバーライドされたメソッドパラメータに「@ {0}」と注釈を付ける
annotate.overridden.methods.parameters.family.name=オーバーライドされたメソッドパラメータに注釈を付ける
assignment.to.declared.variable.problem.descriptor=変数 '' {0} 'は自己割り当てで初期化されています
assignment.to.itself.problem.descriptor=変数 '' {0} ''が自身に割り当てられています
assignment.to.itself.quickfix.name=自己割り当てを削除
boolean.method.is.always.inverted.display.name=ブール法は常に反転されます
boolean.method.is.always.inverted.problem.descriptor=Boolean method <code>\#ref</code> is always inverted
cleanup.in.file=クリーンアップコード
cleanup.in.scope=クリーンアップコード...
configure.annotations.option=注釈の設定
configure.checker.option.assert.false.add.method.checker.dialog.title=アサート偽メソッドを追加する
configure.checker.option.assert.false.method.panel.title=偽のメソッドをアサートする
configure.checker.option.assert.isNotNull.add.method.checker.dialog.title=Assert IsNotNullメソッドを追加する
configure.checker.option.assert.isNotNull.method.panel.title=IsNotNullメソッドをアサートする
configure.checker.option.assert.isNull.add.method.checker.dialog.title=Assert IsNullメソッドを追加する
configure.checker.option.assert.isNull.method.panel.title=IsNullメソッドをアサートする
configure.checker.option.assert.true.add.method.checker.dialog.title=Assert Trueメソッドを追加する
configure.checker.option.assert.true.method.panel.title=真のメソッドをアサートする
configure.checker.option.button=アサート/チェックメソッドの設定
configure.checker.option.isNotNull.add.method.checker.dialog.title=IsNotNullチェックメソッドを追加する
configure.checker.option.isNotNull.method.panel.title=IsNotNullチェックメソッド
configure.checker.option.isNull.add.method.checker.dialog.title=IsNullチェックメソッドを追加する
configure.checker.option.isNull.method.panel.title=IsNullチェックメソッド
configure.checker.option.main.dialog.title=アサート/チェックメソッドの設定
configure.checker.option.overlap.error.msg=設定の競合
configure.checker.option.overlap.error.title=重複チェック
dataflow.message.assigning.null=<code>null</code> is assigned to a variable that is annotated with @NotNull
dataflow.message.assigning.nullable=Expression <code>\#ref</code> might evaluate to null but is assigned to a variable that is annotated with @NotNull
dataflow.message.cce=Casting <code>{0}</code> to <code>\#ref</code> \#loc may produce <code>java.lang.ClassCastException</code>
dataflow.message.constant.condition=Condition <code>\#ref</code> \#loc is always <code>{0}</code>
dataflow.message.constant.condition.when.reached=Condition <code>\#ref</code> \#loc is always <code>{0}</code> when reached
dataflow.message.npe.array.access=Array access <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access=Dereference of <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access.sure=Dereference of <code>\#ref</code> \#loc will produce <code>java.lang.NullPointerException</code>
dataflow.message.npe.method.invocation=Method invocation <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.optional.get.definitely.absent=<code>{0}.\#ref()</code> will definitely fail as {0} is empty here
dataflow.message.optional.get.without.is.present=<code>{0}.\#ref()</code> without ''isPresent()'' check
dataflow.message.passing.null.argument=Passing <code>null</code> argument to parameter annotated as @NotNull
dataflow.message.passing.nullable.argument=Argument <code>\#ref</code> \#loc might be null
dataflow.message.pointless.assignment.expression=Condition <code>\#ref</code> \#loc at the left side of assignment expression is always <code>{0}</code>. Can be simplified
dataflow.message.redundant.instanceof=Condition <code>\#ref</code> \#loc is redundant and can be replaced with <code>\!\= null</code>
dataflow.message.return.null.from.notnull=<code>null</code> is returned by the method declared as @{0}
dataflow.message.return.null.from.notnullable=<code>null</code> is returned by the method which is not declared as @{0}
dataflow.message.return.nullable.from.notnull=Expression <code>\#ref</code> might evaluate to null but is returned by the method declared as @{0}
dataflow.message.return.nullable.from.notnullable=Expression <code>\#ref</code> might evaluate to null but is returned by the method which is not declared as @{0}
dataflow.message.unboxing=Unboxing of <code>\#ref</code> \#loc may produce <code>java.lang.NullPointerException</code>
dataflow.message.unboxing.method.reference=Use of <code>\#ref</code> \#loc would need unboxing which may produce <code>java.lang.NullPointerException</code>
dataflow.message.unreachable.switch.label=Switch label<code>\#ref</code> \#loc is unreachable
dataflow.method.fails.with.null.argument=パラメータがnullの場合、メソッドは例外をスローします。
dataflow.too.complex=Method <code>\#ref</code> is too complex to analyze by data flow algorithm
default.file.template.description=デフォルトのファイルテンプレート
default.file.template.display.name=デフォルトのファイルテンプレートの使用法
default.file.template.edit.template=テンプレートを編集...
default.file.template.replace.with.actual.file.template=実際のファイルテンプレートで置き換える
default.file.template.report.catch.section=デフォルトのキャッチセクションを報告する
default.file.template.report.file.header=既定のファイルヘッダーを報告する
default.file.template.report.method.body=デフォルトの作成/上書き/実装されたメソッド本体を報告する
default.ide.profile.label.text=デフォルトのIDEプロファイル：
dependency.injection.annotations.list=追加の依存性注釈注釈
deprecated.symbol=非推奨シンボル
detach.library.quickfix.name=ライブラリをデタッチする
detach.library.roots.quickfix.name=未使用のライブラリのルートを切り離す
disable.inspection.action.name=検査を無効にする
duplicate.property.diff.key.option=異なる値を持つ重複キー
duplicate.property.diff.key.problem.descriptor=Duplicate Property Key ''{0}'' With Different Values \#treeend \:<br>
duplicate.property.diff.key.progress.indicator.text=重複したプロパティキーの処理：{0}
duplicate.property.display.name=重複するプロパティ
duplicate.property.file.scope.option=ファイルスコープ
duplicate.property.key.option=重複キー
duplicate.property.key.problem.descriptor=Duplicate Property Key ''{0}'' \#treeend With Values\:<br>
duplicate.property.key.progress.indicator.text=重複したプロパティキーの処理：{0}
duplicate.property.module.scope.option=モジュールスコープ
duplicate.property.project.scope.option=プロジェクト範囲
duplicate.property.value.option=重複する値
duplicate.property.value.problem.descriptor=Duplicate Property Value ''{0}'' \#treeend With Keys\:<br>
duplicate.property.value.progress.indicator.text=重複したプロパティ値の処理中：{0}
edit.dependency.rules.family=依存関係ルールを編集する
edit.dependency.rules.text=依存関係ルール "{0}"を編集する
edit.inspection.options='' {0} ''のオプションを編集
edit.options.of.reporter.inspection.family=レポーター検査の編集オプション
edit.options.of.reporter.inspection.text=検査プロファイル設定の編集
error.analysis.is.in.progress=エラー分析が進行中です
errors.single.profile.title=エラー： '' {0} ''検査プロファイル
exports.to.itself.delete.module.ref.fix=モジュール '' {0} ''への参照を削除する
exports.to.itself.delete.statement.fix=文の削除
fix.all.inspection.problems.in.file=ファイル内のすべての '' {0} ''問題を修正しました。
group.names.abstraction.issues=抽象化の問題
group.names.assignment.issues=課題
group.names.bitwise.operation.issues=ビット単位の操作の問題
group.names.class.metrics=クラスメトリック
group.names.class.structure=クラス構造
group.names.cloning.issues=クローニングの問題
group.names.code.maturity.issues=コード成熟度の問題
group.names.code.style.issues=コードスタイルの問題
group.names.compiler.issues=コンパイラの問題
group.names.concurrency.annotation.issues=並行処理アノテーションの問題
group.names.control.flow.issues=制御フローの問題
group.names.data.flow.issues=データフローの問題
group.names.declaration.redundancy=宣言の冗長性
group.names.dependency.issues=依存関係の問題
group.names.encapsulation.issues=カプセル化の問題
group.names.error.handling=エラー処理
group.names.finalization.issues=ファイナンスの問題
group.names.imports=輸入
group.names.inheritance.issues=継承の問題
group.names.initialization.issues=初期化の問題
group.names.internationalization.issues=国際化の問題
group.names.j2me.issues=J2MEの問題
group.names.java.language.level.issues=Java言語レベルの問題
group.names.javabeans.issues=JavaBeansの問題
group.names.javadoc.issues=Javadocの問題
group.names.javaee.issues=Java EEの問題
group.names.junit.issues=JUnitの問題
group.names.language.level.specific.issues.and.migration.aids=Java言語レベルの移行支援
group.names.language.level.specific.issues.and.migration.aids5=Java 5
group.names.language.level.specific.issues.and.migration.aids7=Java 7
group.names.language.level.specific.issues.and.migration.aids8=Java 8
group.names.language.level.specific.issues.and.migration.aids9=Java 9
group.names.logging.issues=ロギングの問題
group.names.memory.issues=メモリの問題
group.names.method.metrics=メソッドメトリック
group.names.modularization.issues=モジュール化の問題
group.names.naming.conventions=命名規則
group.names.numeric.issues=数値問題
group.names.packaging.issues=パッケージの問題
group.names.performance.issues=パフォーマンスの問題
group.names.portability.issues=移植性の問題
group.names.potentially.confusing.code.constructs=潜在的に混乱するコード構成
group.names.probable.bugs=おそらくバグ
group.names.properties.files=プロパティファイル
group.names.resource.management.issues=リソース管理の問題
group.names.security.issues=セキュリティ上の問題
group.names.serialization.issues=シリアル化の問題
group.names.threading.issues=スレッドの問題
group.names.toString.issues=toString（）の問題
group.names.verbose.or.redundant.code.constructs=冗長または冗長コード構成
group.names.visibility.issues=可視性の問題
group.names.xml=XML
highlight.severity.create.dialog.name.label=名
highlight.severity.create.dialog.title=新しいハイライトの重大度
illegal.package.dependencies=不正なパッケージの依存関係
inconsistent.bundle.property.error=不整合なプロパティ '' {0} ''。
inconsistent.bundle.property.inconsistent.end=不一致のプロパティ値end '' {0} ''
inconsistent.bundle.property.inconsistent.end.parent.end.from.check.symbols='' {0} ''が見つかりませんでしたが、 '' {2} ''の '' {1} ''が見つかりません
inconsistent.bundle.property.inconsistent.placeholders=プレースホルダの数が一貫していません： '' {1} ''に{0}が見つかりました
inconsistent.bundle.property.inherited.with.the.same.value=同じ値を持つ '' {0} ''ファイルから継承されたプロパティ
inconsistent.bundle.report.duplicate.properties.values=同じ値でオーバーライドされたレポートプロパティ
inconsistent.bundle.report.inconsistent.properties=不整合なプロパティを報告する
inconsistent.bundle.report.inconsistent.properties.ends=一貫性のないレポートプロパティ
inconsistent.bundle.report.inconsistent.properties.placeholders=一貫性のないプレースホルダを使用してプロパティをレポートする
inconsistent.bundle.report.missing.translations=不足している翻訳を報告する
inconsistent.bundle.untranslated.property.error=翻訳されていないプロパティ '' {0} ''。 
inconsistent.line.separators=一貫しないラインセパレータ
inconsistent.resource.bundle.display.name=一貫性のないリソースバンドル
inspection.1.5.display.name=設定された言語レベルで利用できないAPIの使用
inspection.1.5.problem.descriptor=@since {0} +として文書化されたAPIの使用
inspection.1.7.problem.descriptor=JDK {0}でのコンパイルの問題を引き起こす1.6 API後に生成された使用法
inspection.1.8.problem.descriptor=Default {0, choice, 0\#|1\#method is|2\# methods are} not overridden. It would cause compilation problems with JDK {1}
inspection.1.8.problem.single.descriptor=デフォルトのメソッド '' {0} 'はオーバーライドされません。 
inspection.action.apply.quickfix=クイックフィックスを適用する
inspection.action.apply.quickfix.description=検査クイックフィックスを適用する
inspection.action.edit.settings=編集の設定
inspection.action.export.html=輸出する
inspection.action.export.popup.title=輸出
inspection.action.go.next=次の問題に進む
inspection.action.group.by.severity=重大度別グループ
inspection.action.group.by.severity.description=重大度によるグループ検査
inspection.action.noun=検査
inspection.action.profile.label=検査プロファイル
inspection.action.rerun=検査を再開する
inspection.action.suppress=検査の抑止 '' {0} ''
inspection.action.title=検査
inspection.actiongo.prev=前の問題に戻る
inspection.annotate.method.quickfix.family.name=アノテーションメソッド
inspection.annotate.method.quickfix.name=メソッドを '' @ {0} ''として注釈を付ける
inspection.annotate.quickfix.implements=道具
inspection.annotate.quickfix.overridden.method.messages=メソッド{0} {1}メソッド{2}。
inspection.annotate.quickfix.overridden.method.warning=オーバーライドされたメソッドの警告
inspection.annotate.quickfix.overrides=オーバーライド
inspection.application.cannot.convert.project.0=プロジェクトを変換できません：{0}
inspection.application.cannot.convert.the.project.the.following.files.are.read.only.0=プロジェクトを変換できません。
inspection.application.chosen.profile.log.message=プロファイル '' {0} 'を使って検査しています
inspection.application.directory.cannot.be.found=ディレクトリ{0}が見つかりません
inspection.application.file.cannot.be.found=ファイル{0}が見つかりません
inspection.application.initializing.project=プロジェクトの初期化中...
inspection.application.opening.project=プロジェクトを開く...
inspection.application.project.has.older.format.and.will.be.converted=プロジェクトは古い形式で変換されます。
inspection.application.project.was.succesfully.converted.old.project.files.were.saved.to.0=プロジェクトは正常に変換されました。
inspection.application.starting.up={0}を起動しています...
inspection.as={0}として
inspection.assert.quickfix=アサート '' {0} ''
inspection.can.be.final.accept.quickfix=最終決定する
inspection.can.be.final.display.name=宣言に最終修飾子を付けることができます
inspection.can.be.final.option=レポートクラス
inspection.can.be.final.option1=レポートメソッド
inspection.can.be.final.option2=レポートフィールド
inspection.can.be.local.parameter.problem.descriptor=Parameter <code>\#ref</code> can have <code>final</code> modifier
inspection.can.be.local.variable.problem.descriptor=Variable <code>\#ref</code> can have <code>final</code> modifier
inspection.capitalized.done=完了しました。
inspection.command.line.explanation=Expected parameters\: <projectfilepath> <inspectionprofile> <outputpath> <inspectionsprofile> -- use here profile name configured in the project or locally or path to the inspection profile; can be stabbed when one of the -e|-profileName|-profilePath is used
inspection.comparing.references.display.name=\=\= equals（）の代わりに使用されます。
inspection.comparing.references.problem.descriptor=不審な比較\#ref \#loc
inspection.comparing.references.use.quickfix=equals（）を使用する
inspection.compiler.javac.quirks.anno.array.comma.fix=末尾のカンマを削除
inspection.compiler.javac.quirks.anno.array.comma.problem=注釈配列の初期化子のコンマの後に、一部のJavacバージョン（JDK 5やJDK 6など）でコンパイルエラーが発生することがあります。
inspection.compiler.javac.quirks.name=ジャバクの癖
inspection.compiler.javac.quirks.qualifier.type.args.fix=汎用パラメータを削除
inspection.compiler.javac.quirks.qualifier.type.args.problem=修飾子参照のジェネリックは、一部のJavacバージョン（JDK 5やJDK 6など）でコンパイルエラーを引き起こす可能性があります。
inspection.contract.display.name=契約上の問題
inspection.convert.to.local.quickfix=ローカルに変換する
inspection.data.flow.display.name=定数条件例外
inspection.data.flow.nullable.quickfix.option=<html><body>Suggest @Nullable annotation for methods that may possibly return null and <br>report nullable values passed to non-annotated parameters</body></html>
inspection.data.flow.redundant.instanceof.quickfix=！\= nullに置換
inspection.data.flow.simplify.boolean.expression.quickfix=ブール式の簡略化
inspection.data.flow.simplify.to.assignment.quickfix.name=簡略化して通常の割り当てにする
inspection.data.flow.true.asserts.option=<html><body>Don't report assertions with condition statically proven to be always <code>true</code></body></html>
inspection.dead.code.comment=//  - 検査でコメントアウト
inspection.dead.code.comment.quickfix=コメントアウトする
inspection.dead.code.date.comment=//  - 検査（{0}）によってコメントアウトされました：
inspection.dead.code.display.name=未使用宣言
inspection.dead.code.entry.point.quickfix=エントリーポイントとして追加
inspection.dead.code.entry.points.display.name=エントリーポイント
inspection.dead.code.export.results.instantiated.from.heading=からインスタンス化された
inspection.dead.code.export.results.no.instantiations.found=インスタンス化は見つかりませんでした。
inspection.dead.code.option.applet=アプレット
inspection.dead.code.option.external=Java以外のファイルで使用されるクラス
inspection.dead.code.option.main=<html><code>void main(String args[])</code> methods</html>
inspection.dead.code.option.servlet=サーブレット
inspection.dead.code.problem.synopsis=フィールドは割り当てられません。
inspection.dead.code.problem.synopsis1=フィールドには用途がありません。
inspection.dead.code.problem.synopsis10=匿名クラス宣言コンテキストにはエントリポイントから到達できません。
inspection.dead.code.problem.synopsis11=クラス参照は見つかりませんでした。
inspection.dead.code.problem.synopsis12=クラスには1つのインスタンス化がありますが、エントリポイントからは到達できません。
inspection.dead.code.problem.synopsis13=クラスはインスタンス化されません。
inspection.dead.code.problem.synopsis14=<ul><li>Abstract method is not implemented OR</li><li>Implementation class is never instantiated OR</li><li>An instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis15=<ul><li>Method owner class is never instantiated OR</li><li>An instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis16=メソッドが使用されることはありません。
inspection.dead.code.problem.synopsis17=メソッドには使用法がありますが、それらはすべてエントリポイントから到達可能なメンバを持たないコールチェーンに属します。
inspection.dead.code.problem.synopsis18=エントリポイントからメソッドに到達できません。
inspection.dead.code.problem.synopsis19=Neither the class nor {0, choice, 1\#its implementation|2\#{0,number} its implementations} are ever instantiated.
inspection.dead.code.problem.synopsis2=フィールドは割り当てられますが、決してアクセスされません。
inspection.dead.code.problem.synopsis20=Class has {0, choice, 1\#instantiation|2\#{0,number} instantiations} but they are not reachable from entry points.
inspection.dead.code.problem.synopsis21=メソッドはこの{0}のメンバーとして使用されることはありませんが、実装クラスのメンバーとしてのみ使用されます。
inspection.dead.code.problem.synopsis22=Method overrides a library method but<ul><li>its {0} is never instantiated OR</li><li>its {0} instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis23={0}は実装されていません。
inspection.dead.code.problem.synopsis24={0} has an implementation but <ul><li>it is never instantiated OR</li><li>no instantiations are reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis25={0} has {1, choice, 1\#direct or indirect implementation|2\#{1,number} direct or indirect implementations} but <ul><li>—they are never instantiated OR</li><li>—no instantiations are reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis26.constructor=コンストラクタは使用されません。
inspection.dead.code.problem.synopsis26.method=メソッドが使用されることはありません。
inspection.dead.code.problem.synopsis27.constructor=コンストラクターには用途がありますが、それらはすべてエントリポイントから到達可能なメンバーを持たないコールチェーンに属します。
inspection.dead.code.problem.synopsis27.method=メソッドには使用法がありますが、それらはすべてエントリポイントから到達可能なメンバを持たないコールチェーンに属します。
inspection.dead.code.problem.synopsis28.constructor=コンストラクターには1つの使用法がありますが、エントリーポイントからは到達できません。
inspection.dead.code.problem.synopsis28.method=メソッドには1つの使用法がありますが、エントリポイントからは到達できません。
inspection.dead.code.problem.synopsis29.constructor=Constructor has {0, choice, 1\#usage|2\#{0,number} usages} but they are not reachable from entry points.
inspection.dead.code.problem.synopsis29.method=Method has {0, choice, 1\#usage|2\#{0,number} usages} but they are not reachable from entry points.
inspection.dead.code.problem.synopsis3=フィールドには1つの使用法がありますが、エントリポイントからは到達できません。
inspection.dead.code.problem.synopsis4=Field has {0, choice, 1\#1 usage|2\#{0,number} usages} but they are not reachable from entry points.
inspection.dead.code.problem.synopsis6=Reachable. {0, choice, 1\#1 usage|2\#{0, number} usages} found in the project code.
inspection.dead.code.problem.synopsis6.suspicious=Not Reachable. {0, choice, 1\#1 usage|2\#{0, number} usages} found in the project code.
inspection.dead.code.problem.synopsis7=Has reachable instantiations. {0, choice, 1\#1 instantiation|2\#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis7.suspicious=Has no reachable instantiations. {0, choice, 0\#No instantiations|1\#1 instantiation|2\#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis8=Has reachable implementation instantiations. {0, choice, 1\#1 instantiation|2\#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis8.suspicious=Has no reachable implementation instantiations. {0, choice, 1\#1 instantiation|2\#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis9=Instantiated {0, choice, 1\#1 instantiation|2\#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis9.suspicious=Anonymous class context is not reachable. Class is not instantiated. {0, choice, 1\#1 instantiation|2\#{0, number} instantiations} found in the project code.
inspection.dead.code.remove.from.entry.point.quickfix=エントリーポイントから削除
inspection.dead.code.remove.user.defined.entry.point.quickfix=ユーザー定義のエントリポイントを削除する
inspection.dead.code.safe.delete.quickfix=安全な削除
inspection.dead.code.start.comment=//  - 検査START（{0}）によってコメントアウトされました：
inspection.dead.code.stop.comment=//  - 検査STOP（{0}）によってコメントアウト
inspection.default.annotation.param=デフォルトの注釈パラメータ値
inspection.dependency.configure.button.text=依存関係ルールを設定する
inspection.dependency.violator.problem.descriptor=依存ルール '' {0}。 ''に違反しています
inspection.deprecated.display.name=廃止予定のAPIの使用
inspection.description.title=説明
inspection.diff.format.error=Required parameters\: <oldfile> <newfile> [<deltafilename>]
inspection.disabled.error=点検 '' {0} 'は無効です：{1}。
inspection.disabled.title=検査無効
inspection.disabled.wrong.id=検査 '' {0} 'は無効です：ID' '{1}'は '' {2} ''パターンと一致しません。
inspection.display.name=コードの分析...
inspection.done=完了しました。
inspection.duplicate.throws.display.name=重複スロー
inspection.duplicate.throws.ignore.subclassing.option=他をサブクラス化する例外を無視する
inspection.duplicate.throws.more.general.problem=より一般的な例外があります。既に '' {0} ''がスローリストにあります。
inspection.duplicate.throws.problem=重複スロー
inspection.duplicated.code.display.name=重複コード
inspection.duplicates.display.name=重複した文字列リテラル
inspection.duplicates.message=<html><body>Duplicate string literal found in<br>{0}</body></html>
inspection.duplicates.message.in.this.file=（このファイル内）
inspection.duplicates.message.more=...（{0}件）
inspection.duplicates.option=最小文字列長さ：
inspection.duplicates.option.report.propertykey.expressions=@PropertyKey式を無視する
inspection.duplicates.replace.family.quickfix=置換
inspection.duplicates.replace.quickfix='' {0} ''で置換
inspection.empty.method.delete.quickfix=不要なメソッドを削除する
inspection.empty.method.display.name=空のメソッド
inspection.empty.method.problem.descriptor=メソッドはそのsuperを呼び出します
inspection.empty.method.problem.descriptor1=空のメソッドは空のメソッドをオーバーライドします。
inspection.empty.method.problem.descriptor2=このメソッドは空です
inspection.empty.method.problem.descriptor3=メソッドとそのすべての導出物は空です
inspection.empty.method.problem.descriptor4=このメソッドの実装はすべて空です
inspection.equals.hashcode.display.name=equals（）およびhashCode（）がペアになっていない
inspection.equals.hashcode.generate.equals.quickfix='equals（）'を生成する
inspection.equals.hashcode.generate.hashcode.quickfix='hashCode（）'を生成する
inspection.equals.hashcode.only.one.defined.problem.descriptor=クラスは{0}が定義されていますが、{1}は定義されていません
inspection.error.level.popup.menu.title=エラーレベルを選択
inspection.error.loading.message=Error reading inspection profile {0, choice, 0\#from {1}|1\#}
inspection.errors.occurred.dialog.title=エラーが発生しました
inspection.excessive.lambda.fix.family.name=ラムダを定数で置き換える
inspection.excessive.lambda.fix.name=ラムダなしで '' {0} ''メソッドを使用する
inspection.excessive.lambda.message=過度のラムダ使用
inspection.export.dialog.title=輸出する
inspection.export.error.writing.to={0}への書き込みエラー：{1}
inspection.export.generating.html.for=HTMLの生成：{0}
inspection.export.inspections.link.text=検査
inspection.export.open.option=ブラウザで生成されたHTMLを開く
inspection.export.open.source.link.text=オープンソース
inspection.export.options.panel.title=オプション
inspection.export.results.abstract=抽象
inspection.export.results.abstract.class=抽象的な nbsp;クラス
inspection.export.results.anonymous.ref.in.owner=に
inspection.export.results.at.line=ラインで
inspection.export.results.callees=コールチェーン
inspection.export.results.can.be.final.description=宣言に最終修飾子を付けることができます
inspection.export.results.capitalized.abstract.class=抽象的な nbsp;クラス
inspection.export.results.capitalized.class=クラス
inspection.export.results.capitalized.interface=インタフェース
inspection.export.results.capitalized.location=ロケーション
inspection.export.results.class=クラス
inspection.export.results.constructor=コンストラクタ
inspection.export.results.dead.code=未使用宣言
inspection.export.results.derived.methods=派生したメソッド
inspection.export.results.description.tag=説明
inspection.export.results.error.title=検査結果のエクスポート
inspection.export.results.extended=延長
inspection.export.results.extended.implemented=拡張/実装者
inspection.export.results.extends.implements=拡張/実装
inspection.export.results.field=フィールド
inspection.export.results.file=ファイル
inspection.export.results.implicit.constructor=の暗黙のコンストラクタ
inspection.export.results.initializer=イニシャライザ
inspection.export.results.interface=インタフェース
inspection.export.results.invalidated.item=無効化されたアイテム
inspection.export.results.method=方法
inspection.export.results.no.problems.found=問題は見つかりませんでした
inspection.export.results.overrides.implements=オーバーライド/実装
inspection.export.results.overrides.library.methods=ライブラリメソッドをオーバーライドする
inspection.export.results.package=パッケージ
inspection.export.results.problem.element.tag=問題クラス
inspection.export.results.static=静的
inspection.export.results.suppress=抑止
inspection.export.results.type.references=次はこのタイプを使用します
inspection.export.results.used.from=から使用
inspection.export.results.uses=次のものを使用する
inspection.export.save.button=セーブ
inspection.export.title=コード検査結果
inspection.field.can.be.local.display.name=フィールドはローカルにすることができます
inspection.field.can.be.local.problem.descriptor=フィールドはローカル変数に変換できます
inspection.filter.resolved.action.text=解決済みの項目をフィルタリングする
inspection.filter.show.diff.action.text=差分を表示
inspection.filter.show.diff.only.action.text=差分だけを表示
inspection.general.tools.group.name=一般
inspection.generating.html.progress.title=HTMLの生成...
inspection.generating.xml.progress.title=XMLのダンプ...
inspection.illegal.character=不正な文字
inspection.invalid.node.text=（無効）
inspection.java.module.naming=Javaモジュールの命名規則
inspection.java.module.naming.terminal.digits=モジュール名 '' {0} ''は端末の数字を避けるべきです
inspection.javadoc.dialog.title=追加のJavadocタグを編集する
inspection.javadoc.display.name=宣言にJavadocの問題があります
inspection.javadoc.html.not.required.dialog.title=追加の必須ではないHTML属性の編集
inspection.javadoc.html.not.required.label.text=追加不要のHTML属性：
inspection.javadoc.label.text=追加のJavadocタグ：
inspection.javadoc.lint.display.name=Javadoc（DocLint）におけるHTMLの問題
inspection.javadoc.method.problem.descriptor=パラメータ{1}の{0}タグに説明がありません
inspection.javadoc.method.problem.missing.param.tag=Required tag <code>@param</code> is missing for parameter {0}
inspection.javadoc.method.problem.missing.tag.description={0}タグの説明がありません
inspection.javadoc.option.ignore.deprecated=@deprecatedとマークされた要素を無視する
inspection.javadoc.option.ignore.period=期間の問題を無視する
inspection.javadoc.option.tab.title=クラス
inspection.javadoc.option.tab.title.field=フィールド
inspection.javadoc.option.tab.title.inner.class=インナークラス
inspection.javadoc.option.tab.title.method=方法
inspection.javadoc.option.tab.title.package=パッケージ
inspection.javadoc.problem.add.param.tag=パラメータ '' {0} ''に@paramタグを追加する
inspection.javadoc.problem.add.tag=タグ@ {0} {1}を追加
inspection.javadoc.problem.add.tag.family=不足しているJavadocタグを追加する
inspection.javadoc.problem.cannot.resolve=シンボル{0}を解決できません
inspection.javadoc.problem.descriptor=必要なJavadocが存在しない
inspection.javadoc.problem.descriptor1=ドキュメントの期間がありません。
inspection.javadoc.problem.disallowed.tag=タグ{0}はここでは許可されていません
inspection.javadoc.problem.duplicate.param=パラメータ '' {0} 'の重複する@paramタグ
inspection.javadoc.problem.duplicate.tag=重複する{0}タグ
inspection.javadoc.problem.duplicate.throws=例外 '' {0} 'の重複した@throwsまたは@exceptionタグ
inspection.javadoc.problem.missing.tag=必須のタグ{0}がありません
inspection.javadoc.problem.missing.tag.description=@ {1}タグの後に{0}がありません
inspection.javadoc.problem.name.expected=名前が期待される
inspection.javadoc.problem.pointing.to.itself=Javadoc自身を指し示す
inspection.javadoc.problem.see.tag.expecting.ref=@seeタグの後に、クラス/メソッド参照、引用されたテキスト、またはHTMLリンクが必要です
inspection.javadoc.problem.wrong.tag=間違ったタグ{0}
inspection.javadoc.ref.display.name=Javadocのリファレンスで宣言に問題がある
inspection.javadoc.required.tags.option.title=必須タグ
inspection.javadoc.throws.or.exception.option=@throwsまたは@exception
inspection.lambda.to.method.call.fix.family.name=ラムダ式をメソッド呼び出しで置き換える
inspection.lambda.to.method.call.fix.name=ラムダ式を '' {0} ''に置き換えます
inspection.lambda.to.method.call.message='' {0} ''に置き換えることができます
inspection.local.can.be.final.display.name=ローカル変数またはパラメータは最終的なものにすることができます
inspection.local.can.be.final.option=ローカル変数を報告する
inspection.local.can.be.final.option1=レポートメソッドのパラメータ
inspection.local.can.be.final.option2=レポートキャッチパラメータ
inspection.local.can.be.final.option3=foreachパラメータを報告する
inspection.map.foreach.fix.name=Map.forEachで置き換える
inspection.map.foreach.message='Map.forEach'で置き換えることができます
inspection.map.foreach.option.no.loops=ループを報告しない
inspection.module.exports.package.to.itself=モジュールのエクスポート/パッケージを自分自身に開く
inspection.new.profile.dialog.title=新しいプロファイルを作成する
inspection.new.profile.ide.to.project.warning.message=選択したIDEプロファイルをプロジェクトプロファイルとして保存しますか？
inspection.new.profile.ide.to.project.warning.title=スコープのIDEプロファイルを設定できません
inspection.new.profile.text=新しいプロファイル名
inspection.no.jdk.error.message=このプロジェクトでJDKが正しく設定されていません。
inspection.no.modules.error.message=このプロジェクトにはモジュールは含まれていません。
inspection.no.problems.dialog.title=コード検査
inspection.no.problems.message=疑わしいコードは見つかりませんでした。 
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=@ {0}で注釈を付けられたパラメータは@ {1}パラメータを上書きしてはいけません
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=@ {0}で注釈されたパラメータは、注釈されていないパラメータ
inspection.nullable.problems.NotNull.parameter.receives.null.literal=@ {0}で注釈を付けられたパラメータは引数として 'null'を受け取るべきではありません
inspection.nullable.problems.Nullable.NotNull.conflict=@ {0}と@ {1}の両方で注釈を付けることはできません
inspection.nullable.problems.Nullable.method.overrides.NotNull=@ {0}で注釈を付けられたメソッドは@ {1}メソッドをオーバーライドしてはいけません
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=@ {0}フィールドのコンストラクタパラメータに@ {0}そのものを注釈することができます
inspection.nullable.problems.annotated.field.getter.conflict=@ {0}フィールドのゲッターには@ {1}が注釈されています
inspection.nullable.problems.annotated.field.getter.not.annotated=@ {0}フィールドのゲッターには@ {0}そのものを注釈することができます
inspection.nullable.problems.annotated.field.setter.parameter.conflict=@ {0}フィールドのセッターパラメーターに@ {1}が注釈されています
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=@ {0}フィールドのセッターパラメーターに@ {0}そのものを注釈することができます
inspection.nullable.problems.display.name=@ NotNull / @ Nullableの問題
inspection.nullable.problems.method.overrides.NotNull=注釈付きメソッドは、@ {0}で注釈を付けられたメソッドをオーバーライドしません
inspection.nullable.problems.method.overrides.notnull.option=<html>Report @NotNull parameters overriding @Nullable and <br>@Nullable methods overriding @NotNull</html>
inspection.nullable.problems.method.overrides.option=@NotNullをオーバーライドする非注釈付きのパラメータまたはメソッドを報告する
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=非注釈付きセッターパラメーターまたは注釈付きフィールドのゲッターを報告する
inspection.nullable.problems.parameter.overrides.NotNull=注釈付きパラメータは@ {0}パラメータをオーバーライドしません
inspection.nullable.problems.primitive.type.annotation=プリミティブ型メンバーに注釈を付けることはできません
inspection.offline.view.empty.browser.text=<HTML><BODY>Select inspection result on the left to see details</BODY></HTML>
inspection.offline.view.tool.display.name.title=名
inspection.options.action.text=検査 '' {0} ''のオプション
inspection.parameter.can.be.local.display.name=パラメータはローカルにすることができます
inspection.parameter.can.be.local.problem.descriptor=パラメータはローカル変数に変換できます
inspection.problem.descriptor.count={0, choice, 0\#|1\#(1 item)|2\#({0,number,integer} items)}
inspection.problem.resolution=問題解決
inspection.problem.synopsis=問題の概要
inspection.problems=問題
inspection.processing.job.descriptor=プロジェクトの使用方法の処理
inspection.processing.job.descriptor1=外部用途の処理
inspection.processing.job.descriptor2=のコードを分析する
inspection.profile.unnamed=無名
inspection.progress.title=コードの検査中...
inspection.quickfix.assert.family=アサート
inspection.raw.variable.type.can.be.generic.family.quickfix=型に汎用パラメータを追加する
inspection.raw.variable.type.can.be.generic.name=生のタイプは一般的である
inspection.raw.variable.type.can.be.generic.quickfix={0}のタイプを{1}に変更
inspection.redirect.template=<html><body>Injected element has problem\: {0} (in <a href\="\#navigation/{1}\:{2}">{3}</a>). </body></html>
inspection.redundant.array.creation.display.name=冗長アレイの作成
inspection.redundant.array.creation.for.varargs.call.descriptor=varargsメソッドを呼び出すための冗長配列の作成
inspection.redundant.array.creation.quickfix=明示的な配列作成を削除する
inspection.redundant.cast.display.name=冗長型キャスト
inspection.redundant.cast.problem.descriptor={0}から{1}へのキャストは冗長です
inspection.redundant.cast.remove.quickfix=冗長キャストを削除
inspection.redundant.requires.statement.description=冗長なステートメント ''が必要です{0} ''
inspection.redundant.requires.statement.fix.family=冗長な「要求」ステートメントを削除する
inspection.redundant.requires.statement.fix.name=削除ステートメント ''が必要です{0} ''
inspection.redundant.requires.statement.name=module-infoに冗長な 'requires'ステートメント
inspection.redundant.stream.optional.call.explanation.distinct=チェーンにはすでに「別個の」呼び出しがありました
inspection.redundant.stream.optional.call.explanation.filter=述語は常に真です
inspection.redundant.stream.optional.call.explanation.parallel=この呼び出しをオーバーライドする後続の '' {0} ''呼び出しがあります
inspection.redundant.stream.optional.call.explanation.sorted=後続の '' {0} ''コールが役に立たないソートを行います
inspection.redundant.stream.optional.call.explanation.unordered=チェーンにはすでに「順序付けられていない」呼び出しがあった
inspection.redundant.stream.optional.call.fix.family.name=重複チェーンコールを削除
inspection.redundant.stream.optional.call.fix.name='' {0} ''通話を削除する
inspection.redundant.stream.optional.call.message=冗長な '' {0} ''呼び出し
inspection.redundant.stream.optional.call.option.streamboxing=Stream.mapで無駄なボクシングを報告
inspection.redundant.suppression.description=冗長抑制
inspection.redundant.suppression.name=冗長抑制
inspection.redundant.throws.display.name=冗長スロー句
inspection.redundant.throws.problem.descriptor=宣言された例外{0}は、メソッド実装ではスローされません
inspection.redundant.throws.problem.descriptor1=宣言された例外{0}は、このメソッドまたはその導出物でスローされることはありません
inspection.redundant.throws.problem.descriptor2=宣言された例外{0}は投げられません
inspection.redundant.throws.remove.quickfix=不要なスロー宣言を削除する
inspection.redundant.type.display.name=冗長型引数
inspection.redundant.type.problem.descriptor=明示的な型引数が推論できる
inspection.redundant.type.remove.quickfix=明示的な型引数を削除する
inspection.reference.anonymous=匿名
inspection.reference.anonymous.name=匿名（{0}）
inspection.reference.default.package=<default>
inspection.reference.implicit.constructor.name={0}の暗黙のコンストラクタ
inspection.reference.invalid=要素は存在しません
inspection.reference.jsp.holder.method.anonymous.name=<% page content %>
inspection.reference.noname=ノーネーム
inspection.replace.loop.with.arrays.setall.fix.family.name=loopをArrays.setAllで置き換える
inspection.replace.loop.with.arrays.setall.message=ループはArrays.setAllで置き換えることができます
inspection.replace.ternary.quickfix='' {0}！\= null？： ''と置き換えてください
inspection.replace.with.bulk.fix.family.name=バルクメソッド呼び出しで置き換える
inspection.replace.with.bulk.fix.name=繰り返しをバルクの '' {0} ''呼び出しで置き換える
inspection.replace.with.bulk.message=反復は一括 '' {0} ''呼び出しで置き換えることができます
inspection.replace.with.bulk.wrap.arrays=Arrays.asList（）を使用して配列をラップする
inspection.required.attributes.display.name=必須属性がありません
inspection.results.for.inspection.toolwindow.title='' {0} '' {1}の検査
inspection.results.for.profile.toolwindow.title='' {0} '' {1}のプロフィール
inspection.results.title=エディタ設定による結果
inspection.return.separated.from.computation.descriptor='' {0} ''の値の計算から分離した戻り値
inspection.return.separated.from.computation.family.quickfix=結果の計算に「戻る」を近づける
inspection.return.separated.from.computation.name=結果の計算から分離したリターン
inspection.return.separated.from.computation.quickfix='' {0} 'の値の計算に近づける' 'return' '
inspection.root.node.title=検査
inspection.same.parameter.display.name=実際のメソッドパラメータは同じ定数です
inspection.same.parameter.fix.family.name=定数値としてのインラインパラメータ
inspection.same.parameter.fix.name=パラメータ '' {0} ''のインライン値 '' {1} ''
inspection.same.parameter.problem.descriptor=パラメータ '' {0} 'の実際の値は常に' '{1}' 'です
inspection.same.return.value.display.name=メソッドは同じ値を返します
inspection.same.return.value.problem.descriptor=メソッドは常に{0}を返します。
inspection.same.return.value.problem.descriptor1=メソッドとそのすべての導出物は常に{0}を返します
inspection.same.return.value.problem.descriptor2=このメソッドのすべての実装は、常に{0}を返します。
inspection.scope.for.title=範囲
inspection.scopes.and.severities=スコープとその成果：
inspection.severity=重大度：
inspection.simplify.collector.fix.family.name=カスケードコレクタの簡略化
inspection.simplify.collector.fix.name=コレクター。{0} ''コレクターを使用する
inspection.simplify.collector.message='' {0} ''コレクターを使用して簡略化できます
inspection.surround.if.family=ifで囲む
inspection.surround.if.quickfix=''（{0}！\= null） ''で囲む
inspection.suspicious.collections.method.calls.display.name=不審なコレクションのメソッド呼び出し
inspection.suspicious.collections.method.calls.problem.descriptor='' {0} ''にタイプ '' {1} ''のオブジェクトが含まれていない可能性があります
inspection.suspicious.collections.method.calls.problem.descriptor1='' {0} ''への不審な呼び出し
inspection.test.only.problems.display.name=実動コード内のテスト専用クラスまたはメソッド呼び出し
inspection.test.only.problems.test.only.class.reference=テスト専用クラスは実動コードで参照されています
inspection.test.only.problems.test.only.field.reference=テスト専用フィールドは実動コードで参照されます
inspection.test.only.problems.test.only.method.call=テスト専用メソッドは実動コードで呼び出されます
inspection.tool.availability.in.tree.node=（エディタの強調表示に使用可能）
inspection.tool.availability.in.tree.node1=（Analyze | Inspect Codeで利用可能）
inspection.tool.description.under.construction.text=工事中
inspection.tool.in.browser.description.title=説明
inspection.tool.in.browser.id.title=ID
inspection.tool.window.dialog.no.options=検査 '' {0} ''には設定可能なオプションはありません
inspection.tool.window.dialog.title=検査ツールウィンドウ
inspection.tool.window.inspection.dialog.title=検査 '' {0} ''のオプション
inspection.tools.action.show.global.inspections.description=グローバル検査設定を非表示
inspection.tools.action.show.global.inspections.text=グローバル検査を非表示
inspection.tree.popup.title=解決を受け入れる
inspection.unable.to.create.profile.dialog.title=プロファイルを作成できません。
inspection.unable.to.create.profile.message=名前が '' {0} 'の検査プロファイルは既に存在します。
inspection.unused.assignment.display.name=未使用の割り当て
inspection.unused.assignment.option=レポート++ iはいつ（i + 1）
inspection.unused.assignment.option1=変更された値がその後使用されない場合、i ++を報告する
inspection.unused.assignment.option2=重複初期化子を報告する
inspection.unused.assignment.problem.descriptor1=変数{0}は決して使用されません
inspection.unused.assignment.problem.descriptor2=変数{0}の初期化子{1}が冗長です
inspection.unused.assignment.problem.descriptor3={1}に割り当てられた値{0}は使用されません
inspection.unused.assignment.problem.descriptor4={0}で変更された値は使用されません
inspection.unused.assignment.problem.descriptor5=変数{0}は決して使用されません
inspection.unused.assignment.remove.assignment.quickfix=重複割り当ての削除
inspection.unused.assignment.remove.quickfix=冗長イニシャライザを削除
inspection.unused.parameter.composer=Parameter <code>\#ref</code> is not used in any implementation
inspection.unused.parameter.composer1=Parameter <code>\#ref</code> is not used  in either this method or any of its derived methods
inspection.unused.parameter.delete.quickfix=未使用のパラメータを削除する
inspection.unused.parameter.display.name=未使用のメソッドパラメータ
inspection.unused.return.value.display.name=メソッドは無効にすることができます
inspection.unused.return.value.make.void.quickfix=メソッドを 'void'にする
inspection.unused.return.value.problem.descriptor=メソッドの戻り値は使用されません
inspection.unused.symbol.check.accessors=ゲッター/セッター
inspection.unused.symbol.check.classes=クラス：
inspection.unused.symbol.check.fields=フィールド：
inspection.unused.symbol.check.inner.classes=内部クラス：
inspection.unused.symbol.check.localvars=ローカル変数
inspection.unused.symbol.check.methods=メソッド：
inspection.unused.symbol.check.parameters=のパラメータ
inspection.unused.symbol.public.method.parameters=非プライベートメソッドのパラメータをチェックする
inspection.variable.assigned.to.itself.display.name=変数はそれ自身に割り当てられます
inspection.visibility.accept.quickfix=推奨アクセスレベルを受け入れる
inspection.visibility.compose.suggestion={0}にすることができます
inspection.visibility.display.name=宣言アクセスが弱い
inspection.visibility.option=クラスメンバーのパッケージプライベート可視性レベルを提案する
inspection.visibility.option1=最上位クラスのパッケージプライベート可視性レベルを提案する
inspection.visibility.option2=<html>Suggest private for inner class members when referenced from outer class only</html>
inspections.dead.code.entry.points.annotations.list.title=追加エントリポイントの注釈
inspections.view.options.title=検査{0}オプション
introduce.constant.across.the.project=プロジェクト全体に定数を導入する
long.line.display.name=行がコードスタイルで許可されている長さよりも長い
lossy.encoding=ロスエンコーディング
no.errors.found.in.this.file=このファイルにエラーはありません
nothing.found=何も見つかりません
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name='null'引数の使用にナビゲートする
nullable.stuff.inspection.navigate.null.argument.usages.view.name=パラメータ '{0}'の 'null'引数の使用方法
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=オーバーライドされたメソッドパラメータに注釈は付けられません
nullable.stuff.problems.overridden.methods.are.not.annotated=オーバーライドされたメソッドは注釈されません
offline.inspections.jdk.not.found={0}が見つかりません
offline.inspections.library.was.not.resolved=モジュール '' {1} ''で使用されているライブラリ '' {0} ''を構成してください
offline.inspections.module.jdk.not.found=モジュール '' {1} ''にsdk '' {0} ''を指定してください
offline.view.editor.settings.title=エディタの設定
offline.view.parse.exception.title=表示するものはありません
offline.view.title=オフライン表示
parsing.inspections.dump.progress.title=検査の解析XMLダンプ
preparing.for.apply.fix=修正を適用する準備をしています...
problematic.whitespace.display.name=問題のある空白
problematic.whitespace.show.whitespaces.quickfix=エディタで空白の表示を切り替える
problematic.whitespace.spaces.problem.descriptor=ファイル '' {0} ''はインデントにスペースを使用します
problematic.whitespace.tabs.problem.descriptor=ファイル '' {0} ''はインデント用のタブを使用します
profile.activate.action.text=プロジェクトのデフォルトとして設定する
profile.assignment.repeatable.scope.warning=反復可能な範囲。
profile.assignments.browse.profile.scopes.dialog.title=プロファイルスコープ
profile.assignments.browse.scope.button.title=ブラウズ...
profile.assignments.display.name=エラー
profile.assignments.table.title=プロジェクト検査プロファイルの割り当て
profile.banner.text=Inspection profile\: {0} {1, choice, 0\#(inactive)|1\#}
profile.default.profile.title=既定のプロジェクトプロファイル
profile.ide.profile.radiobutton.title=IDEプロファイル
profile.ide.settings.banner=IDEプロファイル設定
profile.ide.tree.text=IDEプロファイル
profile.lock.action.text=ロック
profile.mapping.inspection.profile.column.title=検査プロファイル
profile.mapping.scope.column.title=範囲
profile.project.activate.action.text=IDEのデフォルトとして設定する
profile.project.display.name=プロジェクトプロファイル
profile.project.radiobutton.title=プロジェクトのプロフィール
profile.project.settings.banner=プロジェクトプロファイルの設定
profile.project.settings.disable.text=< Use IDE Profile >
profile.quick.change.suggestion.dialog.title=プロファイルを切り替えることができません
profile.quick.change.suggestion.message=<html>There are a few scopes configured for the project. Do you want to edit profile assignments on them?</html>
profile.save.as.ide.checkbox.title=IDEプロファイルとして保存
profile.save.as.project.checkbox.title=プロジェクトプロファイルとして保存
profile.unlock.action.text=ロックを解除する
redundant.throws.declaration=冗長スロー宣言
rename.inspection.profile=検査プロファイルの名前を変更する
rename.message.prefix.inspection.profile=検査プロファイル
report.suspicious.but.possibly.correct.method.calls=疑わしいが、場合によっては正しいメソッド呼び出しを報告する
run.inspection.on.file.intention.text=検査を実行する...
run.with.choosen.profile.dialog.option=選択したプロファイルで実行
run.with.editor.settings.dialog.option=エディタ設定で実行
severities.default.settings.message=設定の編集|色/フォント
severities.editor.dialog.title=重大度エディタ
special.annotations.annotations.list=その他の特別な注釈
special.annotations.list.add.annotation.class=注釈クラスを追加する
special.annotations.list.annotation.class=アノテーションクラス
special.annotations.list.annotation.pattern=注釈パターンを追加する
special.annotations.list.remove.annotation.class=注釈クラスを削除する
suppress.all.for.class=クラスのすべての点検を抑止する
suppress.inspection.annotation.syntax.error=不適切な注釈構文：{0}
suppress.inspection.class=クラスを非表示にする
suppress.inspection.family=検査を抑止する
suppress.inspection.field=フィールドの抑制
suppress.inspection.member=メンバーを非表示にする
suppress.inspection.method=メソッドの非表示
suppress.inspection.problem=抑止
suppress.inspection.statement=声明を抑制する
suspected.module.dependency.problem.descriptor=モジュール '' {0} ''はモジュール '' {1} ''に依存しません。
suspicious.name.combination.add.titile=名前のグループを追加する
suspicious.name.combination.display.name=不審な変数とパラメータ名の組み合わせ
suspicious.name.combination.edit.title=名前のグループを編集する
suspicious.name.combination.options.prompt=カンマで区切った名前のリストを入力します。
suspicious.name.combination.options.title=名前のグループ
todo.comment.display.name=TODOコメント
todo.comment.problem.descriptor=TODO comment <code>\#ref</code> \#loc
unchecked.warning=未確認の警告
unhandled.exception.in.jsp.name=JSPで未処理の例外
unnecessary.module.dependency.display.name=不要なモジュール依存
unnecessary.module.dependency.exported.problem.descriptor=モジュール '' {0} ''は '' {1} ''に依存しません。
unnecessary.module.dependency.exported.problem.descriptor1=モジュール '' {0} ''は '' {1} ''に依存しません。 
unnecessary.module.dependency.problem.descriptor=モジュール '' {0} ''のソースはモジュール '' {1} ''のソースに依存しません
unsupported.character.for.the.charset=文字セット '' {0} ''のサポートされていない文字
unused.import=未使用のインポート（エディタのライト）
unused.import.statement=未使用のインポートステートメント
unused.library.backward.analysis.job.description=後方分析を実行する
unused.library.display.name=未使用ライブラリ
unused.library.problem.descriptor=未使用ライブラリ '' {0} ''
unused.library.roots.problem.descriptor=ライブラリ '' {1} ''の未使用ルート{0}
unused.symbol=未使用シンボル
wrong.package.statement=間違ったパッケージステートメント
xml.suppressable.all.for.file.title=すべてのファイルを非表示にする
xml.suppressable.for.file.title=ファイルの非表示
xml.suppressable.for.tag.title=タグの非表示
